<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>勉強進捗管理</title>
    <link rel="apple-touch-icon" href="icon.png">
    <meta name="apple-mobile-web-app-title" content="学習管理">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>

    <script>
        tailwind.config = {
            darkMode: 'class', // クラス切り替えモード
            theme: {
                extend: {
                    colors: {
                        // 変数を使うように変更
                        'app-dark': 'var(--bg-main)',
                        'app-panel': 'var(--bg-panel)',
                        'app-accent': 'var(--accent)',
                        'app-success': '#10b981',
                        'app-text': 'var(--text-main)',
                        'app-sub': 'var(--text-sub)',
                        'challenge-gold': '#fbbf24',
                        'app-weak': '#ef4444',

                        // 既存のグレー色も変数で乗っ取る（ここが裏技！）
                        gray: {
                            900: 'var(--c-gray-900)',
                            800: 'var(--c-gray-800)',
                            700: 'var(--c-gray-700)',
                            400: 'var(--c-gray-400)',
                            // 他はデフォルトのまま
                            50: '#f9fafb', 100: '#f3f4f6', 200: '#e5e7eb', 300: '#d1d5db',
                            500: '#6b7280', 600: '#4b5563'
                        }
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        mono: ['ui-monospace', 'SFMono-Regular', 'Menlo', 'Monaco', 'Consolas', "Liberation Mono", "Courier New", 'monospace'],
                    },
                    animation: {
                        'pulse-fast': 'pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                    }
                }
            }
        }
    </script>
    <style>
        /* ★修正：スクロールバーも変数対応 */
        ::-webkit-scrollbar {
            width: 4px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-panel);
        }

        ::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 2px;
        }

        /* ★修正：bodyの背景色を「固定の黒」から「変数」に変更 */
        body {
            background-color: var(--bg-main);
            color: var(--text-main);
        }

        .category-label-top {
            text-align: center;
            border-bottom: 1px solid var(--c-gray-700);
            padding: 2px 1px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 8px;
            color: var(--text-sub);
            box-sizing: border-box;
        }

        /* ★修正：単元マップの枠背景を変数に */
        .slit-wrapper {
            display: flex;
            width: 100%;
            height: 150px;
            border: 1px solid var(--c-gray-700);
            border-radius: 4px;
            overflow: hidden;
            background-color: var(--bg-main);
        }

        /* ★修正：スリットの背景を変数に */
        .slit-item {
            flex: 1;
            position: relative;
            border-right: 1px solid var(--c-gray-700);
            /* 境界線は薄い黒のままでOK */
            background-color: var(--bg-panel);
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            overflow: hidden;
            padding-top: 4px;
            padding-bottom: 4px;
        }

        .slit-item:last-child {
            border-right: none;
        }

        .slit-text {
            flex-grow: 1;
            writing-mode: vertical-rl;
            text-orientation: upright;
            letter-spacing: 1px;
            font-size: 9px;
            line-height: 1;
            padding-top: 2px;
            padding-bottom: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
        }

        .slit-item.completed {
            background-color: #10b981;
        }

        .slit-item.completed .slit-text {
            color: rgba(0, 0, 0, 0.6);
            font-weight: bold;
        }

        .slit-item.completed.weak {
            background-color: #fbbf24;
        }

        .slit-item.weak-pending {
            background-color: #7f1d1d;
        }

        .slit-item.weak-pending .slit-text {
            color: #fca5a5;
            font-weight: bold;
        }

        .slit-item:hover {
            filter: brightness(1.2);
        }

        .slit-weak-btn {
            font-size: 8px;
            margin-top: 2px;
            z-index: 10;
            color: rgba(255, 255, 255, 0.2);
            /* アイコンは薄い白系で固定でも可 */
            transition: color 0.2s;
            width: 100%;
            text-align: center;
            padding: 2px 0;
        }

        .slit-weak-btn:hover,
        .slit-weak-btn.active {
            color: #ef4444;
            opacity: 1;
            text-shadow: 0 0 2px black;
        }

        /* 完了済みスリットの中のボタン色調整 */
        .slit-item.completed .slit-weak-btn {
            color: rgba(0, 0, 0, 0.2);
        }

        .slit-item.completed .slit-weak-btn:hover,
        .slit-item.completed .slit-weak-btn.active {
            color: #ef4444;
        }

        /* ★追加：ライトモード時の単元マップ視認性向上 */
        html.light-mode .slit-wrapper {
            border-color: #94a3b8;
        }

        html.light-mode .slit-item {
            border-right-color: #94a3b8;
        }

        html.light-mode .slit-item:not(.completed):not(.weak-pending) .slit-weak-btn {
            color: rgba(0, 0, 0, 0.3);
        }

        html.light-mode .slit-item:not(.completed):not(.weak-pending) .slit-weak-btn:hover,
        html.light-mode .slit-item:not(.completed):not(.weak-pending) .slit-weak-btn.active {
            color: #ef4444;
        }

        /* ★修正：ヒートマップの背景を変数に */
        .month-heat-item {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            border-right: 1px solid var(--c-gray-700);
            background-color: var(--bg-panel);
            position: relative;
        }

        .month-heat-fill {
            width: 100%;
            transition: height 0.5s ease;
            opacity: 0.8;
        }

        .month-heat-label {
            font-size: 10px;
            color: var(--text-sub);
            margin-top: 4px;
            position: absolute;
            bottom: 4px;
            z-index: 10;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
        }

        .tab-content {
            display: none;
            padding-bottom: 120px;
        }

        .tab-content.active {
            display: block;
        }

        #calendar-screen.active {
            display: flex !important;
        }

        .calendar-day {
            aspect-ratio: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 0.375rem;
            cursor: pointer;
            position: relative;
            font-size: 0.875rem;
        }

        .calendar-day:hover {
            background-color: var(--c-gray-700);
        }

        .calendar-day.today {
            border: 1px solid #38bdf8;
            color: #38bdf8;
            font-weight: bold;
        }

        .has-event-dot {
            width: 4px;
            height: 4px;
            background-color: #38bdf8;
            border-radius: 50%;
            position: absolute;
            bottom: 4px;
        }

        .has-completed-mark {
            position: absolute;
            bottom: 4px;
            right: 4px;
            font-size: 8px;
            color: #10b981;
        }

        .challenge-mark {
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 10px;
            color: #fbbf24;
        }

        select.custom-select {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%2394a3b8' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 0.5rem center;
            background-repeat: no-repeat;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
            appearance: none;
        }

        .fire-aura {
            position: relative;
        }

        .fire-aura::before {
            content: '';
            position: absolute;
            top: -10px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            background: radial-gradient(circle, rgba(255, 69, 0, 0.4) 0%, rgba(255, 215, 0, 0) 70%);
            border-radius: 50%;
            z-index: -1;
            animation: fire-pulse 1.5s infinite alternate;
            filter: blur(8px);
        }

        .fire-aura::after {
            content: '';
            position: absolute;
            top: -5px;
            left: -5px;
            right: -5px;
            bottom: -5px;
            background: radial-gradient(circle, rgba(255, 140, 0, 0.6) 0%, rgba(255, 69, 0, 0) 70%);
            border-radius: 50%;
            z-index: -1;
            animation: fire-pulse 1s infinite alternate-reverse;
            filter: blur(4px);
        }

        @keyframes fire-pulse {
            0% {
                transform: scale(0.95);
                opacity: 0.6;
            }

            100% {
                transform: scale(1.1);
                opacity: 1;
            }
        }

        .text-fire {
            background: linear-gradient(to bottom, #ffd700, #ff4500);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 900;
            filter: drop-shadow(0 0 5px rgba(255, 69, 0, 0.5));
        }

        #debug-mode-indicator {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: repeating-linear-gradient(45deg, #f59e0b, #f59e0b 10px, #000 10px, #000 20px);
            z-index: 100;
        }

        #custom-alert-box {
            animation: slideUp 0.2s ease-out;
        }

        @keyframes slideUp {
            from {
                transform: translateY(10px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        nav#app-nav {
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.5);
        }

        .weak-checkbox:checked+div {
            background-color: #ef4444;
            color: white;
            border-color: #ef4444;
        }

        /* ★ここから下は前回追加した変数の定義（そのまま残しておいてください） */
        :root {
            /* ダークモード（デフォルト） */
            --bg-main: #0f172a;
            --bg-panel: #1e293b;
            --text-main: #e2e8f0;
            --text-sub: #94a3b8;
            --accent: #38bdf8;

            --c-gray-900: #111827;
            --c-gray-800: #1f2937;
            --c-gray-700: #374151;
            --c-gray-400: #9ca3af;
        }

        html.light-mode {
            --bg-main: #f1f5f9;
            --bg-panel: #ffffff;
            --text-main: #334155;
            --text-sub: #64748b;
            --accent: #0284c7;

            --c-gray-900: #f1f5f9;
            --c-gray-800: #e2e8f0;
            --c-gray-700: #cbd5e1;
            --c-gray-400: #64748b;
        }

        html.light-mode body {
            color: var(--text-main);
        }

        html.light-mode .text-white {
            color: var(--text-main) !important;
        }

        html.light-mode .text-gray-300 {
            color: var(--text-sub) !important;
        }

        html.light-mode .text-gray-400 {
            color: var(--text-sub) !important;
        }

        html.light-mode .text-gray-500 {
            color: #94a3b8 !important;
        }

        /*119

        /* ★追加：PayPay風の中央浮き出しボタン */
        .nav-center-wrapper {
            position: relative;
            width: 60px;
            height: 100%;
        }

        .nav-center-btn {
            position: absolute;
            bottom: 24px;
            /* バーより上に飛び出させる */
            left: 50%;
            transform: translateX(-50%);
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: var(--accent);
            /* アクセントカラー */
            color: var(--bg-main);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 60;
            border: 4px solid var(--bg-panel);
            /* 背景色で縁取りして「切り抜き」感を出す */
            transition: transform 0.1s;
        }

        .nav-center-btn:active {
            transform: translateX(-50%) scale(0.95);
        }

        .nav-center-btn i {
            font-size: 20px;
            margin-bottom: 2px;
        }

        .nav-center-btn span {
            font-size: 9px;
            font-weight: bold;
        }

        /* 週間チェック表のデザイン */
        .challenge-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
        }

        .challenge-th {
            font-size: 10px;
            color: var(--text-sub);
            text-align: center;
            padding: 4px;
            border-bottom: 1px solid var(--c-gray-700);
            font-weight: normal;
        }

        .challenge-th.today {
            color: var(--accent);
            font-weight: bold;
        }

        .challenge-row {
            transition: background-color 0.2s;
        }

        .challenge-row:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .challenge-name-cell {
            max-width: 100px;
            padding: 8px;
            font-size: 12px;
            font-weight: bold;
            color: var(--text-main);
            border-bottom: 1px solid var(--c-gray-800);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .challenge-check-cell {
            padding: 4px;
            text-align: center;
            border-bottom: 1px solid var(--c-gray-800);
        }

        .check-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            background-color: var(--c-gray-800);
            border: 1px solid var(--c-gray-700);
            color: transparent;
        }

        .check-btn.checked {
            background-color: #fbbf24;
            /* Challenge Gold */
            border-color: #fbbf24;
            color: #1e293b;
            box-shadow: 0 2px 5px rgba(251, 191, 36, 0.4);
            transform: scale(1.1);
        }

        /* 今日の分が未完了なら強調 */
        .check-btn.today-incomplete {
            border-color: #ef4444;
            box-shadow: 0 0 8px rgba(239, 68, 68, 0.4);
            animation: pulse-border 2s infinite;
        }

        @keyframes pulse-border {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.6;
            }

            100% {
                opacity: 1;
            }
        }

        /* ★追加：ニュースティッカーのアニメーション */
        .ticker-slide-enter {
            animation: slide-in-bottom 0.5s cubic-bezier(0.16, 1, 0.3, 1) forwards;
        }

        .ticker-slide-exit {
            animation: slide-out-top 0.5s cubic-bezier(0.16, 1, 0.3, 1) forwards;
        }

        @keyframes slide-in-bottom {
            0% {
                transform: translateY(100%);
                opacity: 0;
            }

            100% {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes slide-out-top {
            0% {
                transform: translateY(0);
                opacity: 1;
            }

            100% {
                transform: translateY(-100%);
                opacity: 0;
            }
        }

        .ticker-item {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 0 20px;
        }

        .ticker-category-badge {
            font-size: 9px;
            padding: 1px 4px;
            border-radius: 2px;
            margin-right: 6px;
            white-space: nowrap;
            font-weight: bold;
            /* border: 1px solid currentColor; */
            opacity: 0.8;
        }
    </style>

</head>

<body class="antialiased font-sans h-screen flex flex-col overflow-hidden text-app-text"
    style="opacity: 0; transition: opacity 0.5s;">

    <div id="login-modal" class="fixed inset-0 bg-app-dark z-[999] flex items-center justify-center p-4">
        <div class="bg-app-panel border border-gray-600 rounded-lg w-full max-w-sm p-6 shadow-2xl">
            <h2 class="text-xl font-bold text-white mb-6 text-center">
                学習管理アプリ<br>
                <span class="text-[10px] text-red-400 font-normal">※商用アプリでないので紹介された人しか使わないでください。</span>
            </h2>
            <div class="space-y-4">
                <p class="text-xs text-gray-400 mb-4 text-center">Google ToDoリストと同期するために<br>Googleアカウントでログインしてください</p>
                <button onclick="performGoogleLogin()"
                    class="flex items-center justify-center w-full bg-white text-gray-700 font-bold py-3 px-4 rounded shadow-md hover:bg-gray-100 transition-colors">
                    <svg class="w-5 h-5 mr-3" viewBox="0 0 24 24">
                        <path
                            d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
                            fill="#4285F4" />
                        <path
                            d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
                            fill="#34A853" />
                        <path
                            d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.84z"
                            fill="#FBBC05" />
                        <path
                            d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
                            fill="#EA4335" />
                    </svg>
                    Googleでログイン
                </button>
                <p id="login-error" class="text-red-400 text-xs text-center min-h-[1rem]"></p>
            </div>
        </div>
    </div>

    <header class="flex items-center px-4 py-2 bg-app-panel border-b border-gray-700 z-10 h-14 shrink-0 gap-3">
        <div class="w-32 shrink-0">
            <select id="subject-select"
                class="custom-select bg-gray-900 border border-gray-600 text-white text-xs rounded px-2 py-1 focus:outline-none focus:border-app-accent w-full truncate">
            </select>
        </div>

        <div id="header-date-display" class="text-sm font-mono font-bold text-gray-200 whitespace-nowrap">--/--</div>

        <div id="header-ticker-box"
            class="hidden sm:block flex-1 relative h-8 bg-gray-900/50 rounded overflow-hidden cursor-pointer group select-none border-none outline-none ring-0"
            style="border: none !important; outline: none !important; box-shadow: none !important;"
            onclick="forceNextTicker()">
            <div class="ticker-wrapper relative w-full h-full">
                <div class="ticker-item text-xs text-gray-500">Loading...</div>
            </div>
            <button
                class="ticker-pause-btn absolute right-1 bottom-0.5 text-[8px] text-gray-600 hover:text-white opacity-0 group-hover:opacity-100 transition-opacity z-20 p-1"
                onclick="toggleTickerPause(event)">
                <i class="fas fa-pause"></i>
            </button>
        </div>

        <div class="flex items-center justify-end gap-2 shrink-0 ml-auto">
            <div class="flex flex-col items-end">
                <div class="text-[10px] text-app-accent font-mono whitespace-nowrap hidden sm:block"
                    id="exam-days-left">目標まで -- 日</div>
                <div class="text-[9px] text-challenge-gold font-bold whitespace-nowrap hidden sm:block"
                    id="streak-count-header"></div>
            </div>

            <button onclick="syncFromGoogleTasks()"
                class="bg-gray-800 hover:bg-gray-700 text-app-accent border border-gray-600 rounded px-2 py-1.5 flex items-center gap-2 transition-colors active:scale-95 mx-1">
                <i class="fas fa-sync-alt text-xs"></i>
                <span class="text-[10px] font-bold hidden md:inline">同期</span>
            </button>

            <button onclick="openSettingsModal()" class="text-gray-400 hover:text-white p-1.5"><i
                    class="fas fa-cog"></i></button>
        </div>
    </header>

    <main class="flex-1 overflow-y-auto relative scroll-smooth" id="main-container">

        <div id="home-screen" class="tab-content active p-4 pb-32">
            <div class="sm:hidden text-center mb-2">
                <span class="text-[10px] text-app-accent font-mono bg-app-accent/10 px-2 py-1 rounded"
                    id="exam-days-left-mobile">目標まで -- 日</span>
            </div>
            <div class="sm:hidden text-center mb-4 min-h-[16px]">
                <span class="text-[10px] text-challenge-gold font-bold" id="streak-count-mobile"></span>
            </div>

            <div class="flex flex-col items-center justify-center mb-6">
                <div id="progress-container" class="relative w-32 h-32 transition-all duration-500">
                    <canvas id="progressCircleChart"></canvas>
                    <div class="absolute inset-0 flex flex-col items-center justify-center pointer-events-none">
                        <span class="text-xs text-gray-400" id="progress-label">進捗率</span>
                        <span class="text-2xl font-bold text-white tracking-tighter transition-all duration-300"
                            id="total-progress-text">0%</span>
                    </div>
                </div>
                <div class="mt-2 text-xs text-gray-500" id="current-subject-name-display"></div>
            </div>

            <div class="mb-8">
                <div class="flex justify-between items-end mb-2">
                    <h2 class="text-xs font-medium text-gray-400 uppercase tracking-widest" id="map-title">単元マップ</h2>
                </div>
                <div id="category-labels-container" class="flex w-full overflow-hidden border-x border-transparent">
                </div>
                <div id="slit-bar-wrapper" class="slit-wrapper"></div>
                <div class="flex justify-end mt-2 gap-3 text-[10px] text-gray-500" id="map-legend">
                    <div class="flex items-center gap-1">
                        <div class="w-2 h-2 rounded-full bg-app-success"></div>完了
                    </div>
                    <div class="flex items-center gap-1">
                        <div class="w-2 h-2 rounded-full bg-challenge-gold"></div>完了(苦手)
                    </div>
                    <div class="flex items-center gap-1">
                        <div class="w-2 h-2 rounded-full bg-app-weak"></div>未完(苦手)
                    </div>
                </div>
            </div>

            <div class="bg-app-panel rounded-lg p-4 border border-gray-700 shadow-sm mb-6">
                <h2 class="text-xs font-medium text-gray-400 mb-3 flex items-center justify-between">
                    <span><i class="fas fa-chart-line text-app-accent mr-1"></i> ペース予測・推移</span>
                    <span class="text-[9px] text-gray-500" id="chart-legend-note">※オレンジは現在のペース予測</span>
                </h2>
                <div class="relative h-48 w-full">
                    <canvas id="paceChart"></canvas>
                </div>
            </div>


        </div>

        <div id="record-screen" class="tab-content p-4 pb-32">
            <section class="mb-6">
                <div
                    class="flex items-center justify-between mb-3 bg-app-panel/50 p-2 rounded-lg border border-gray-700/50">
                    <div class="flex items-center gap-3">
                        <button id="record-prev-day"
                            class="text-gray-400 hover:text-white w-8 h-8 flex items-center justify-center rounded-full hover:bg-gray-700 transition-colors"><i
                                class="fas fa-chevron-left"></i></button>
                        <h2 class="text-sm font-bold text-white flex flex-col items-center">
                            <span id="record-date-label">今日の予定</span>
                            <span id="record-date-display"
                                class="text-[10px] font-normal text-gray-400 uppercase"></span>
                        </h2>
                        <button id="record-next-day"
                            class="text-gray-400 hover:text-white w-8 h-8 flex items-center justify-center rounded-full hover:bg-gray-700 transition-colors"><i
                                class="fas fa-chevron-right"></i></button>
                    </div>
                    <span id="record-task-count"
                        class="text-[10px] bg-app-accent/10 text-app-accent px-2 py-0.5 rounded border border-app-accent/20">0
                        単元</span>
                </div>

                <div id="challenge-action-area" class="hidden mb-4">
                    <div class="bg-app-panel rounded-lg p-6 border border-gray-700 text-center">
                        <h3 class="text-white font-bold mb-4">今日のチャレンジを記録</h3>
                        <button id="challenge-toggle-btn"
                            class="w-full py-4 rounded-xl font-bold text-lg shadow-lg transition-all duration-300 transform active:scale-95 flex items-center justify-center gap-2">
                            <i class="fas fa-check-circle"></i> <span id="challenge-btn-text">完了にする</span>
                        </button>
                    </div>
                </div>

                <div class="bg-app-panel rounded-lg border border-gray-700 overflow-hidden min-h-[60px]"
                    id="todays-list"></div>
                <div class="mt-3 flex justify-between items-center px-1">
                    <p class="text-[10px] text-gray-500">全科目の予定が表示されます</p>
                    <button onclick="copyForKeep()"
                        class="text-xs bg-gray-800 hover:bg-gray-700 text-gray-300 px-3 py-1.5 rounded flex items-center gap-2 border border-gray-700 transition-colors active:scale-95"><i
                            class="far fa-copy"></i> テキストコピー</button>
                </div>
                <div id="copy-feedback" class="text-center text-[10px] text-app-success mt-1 hidden">コピーしました！</div>
            </section>

            <section id="record-queue-section">
                <div class="flex items-center justify-between mb-3">
                    <h2 class="text-sm font-bold text-gray-400 flex items-center gap-2">
                        <span class="w-1 h-4 bg-gray-600 rounded-sm"></span>
                        残りの単元 (<span id="current-subject-name-record"></span>)
                    </h2>
                </div>
                <div class="bg-app-panel/30 rounded-lg border border-gray-800 overflow-hidden" id="queue-list"></div>
            </section>
        </div>

        <div id="calendar-screen" class="tab-content h-full flex-col p-2 sm:p-4">
            <div class="flex items-center mb-3 shrink-0 gap-4">
                <h2 class="text-lg font-bold text-white flex items-center gap-2 min-w-[120px]">
                    <i class="far fa-calendar-alt text-app-accent"></i>
                    <span id="calendar-title"></span>
                </h2>

                <div class="flex-1 flex justify-end items-center gap-2">
                    <button onclick="currentCalendarDate = new Date(); renderCalendar();"
                        class="text-[10px] bg-gray-700 text-gray-200 font-bold px-3 py-1.5 rounded-full hover:bg-gray-600 transition-colors border border-gray-600">
                        今日
                    </button>

                    <div class="flex bg-gray-800 rounded-full p-1 border border-gray-700">
                        <button id="prev-month"
                            class="text-gray-400 hover:text-white px-2 py-0.5 hover:bg-gray-700 rounded-full transition-colors">
                            <i class="fas fa-chevron-left text-xs"></i>
                        </button>
                        <div class="w-[1px] bg-gray-700 mx-1"></div>
                        <button id="next-month"
                            class="text-gray-400 hover:text-white px-2 py-0.5 hover:bg-gray-700 rounded-full transition-colors">
                            <i class="fas fa-chevron-right text-xs"></i>
                        </button>
                    </div>
                </div>
            </div>

            <div class="flex-1 flex flex-col bg-app-panel rounded-xl border border-gray-700 shadow-xl overflow-hidden">
                <div class="grid grid-cols-7 border-b border-gray-700 bg-gray-800/50">
                    <div class="py-2 text-center text-xs font-bold text-red-400">日</div>
                    <div class="py-2 text-center text-xs font-bold text-gray-400">月</div>
                    <div class="py-2 text-center text-xs font-bold text-gray-400">火</div>
                    <div class="py-2 text-center text-xs font-bold text-gray-400">水</div>
                    <div class="py-2 text-center text-xs font-bold text-gray-400">木</div>
                    <div class="py-2 text-center text-xs font-bold text-gray-400">金</div>
                    <div class="py-2 text-center text-xs font-bold text-blue-400">土</div>
                </div>

                <div id="calendar-grid" class="flex-1 grid grid-cols-7 grid-rows-6"></div>
            </div>

            <div class="mt-2 text-[10px] text-gray-500 shrink-0 px-1">
                <div class="flex flex-wrap items-center gap-x-3 gap-y-1">
                    <span class="flex items-center gap-1"><span
                            class="w-2 h-2 rounded-full bg-app-accent"></span>予定</span>
                    <span class="flex items-center gap-1"><span
                            class="w-2 h-2 rounded-full bg-app-success"></span>完了</span>
                    <span class="flex items-center gap-1"><span
                            class="w-2 h-2 rounded-full bg-challenge-gold"></span>★チャレンジ</span>
                </div>
                <div id="calendar-legend" class="mt-1 flex flex-wrap gap-x-3 gap-y-1 opacity-80"></div>
            </div>
        </div>

        <div id="challenge-screen" class="tab-content p-4 pb-32">
            <h2 class="text-lg font-bold text-white mb-4 flex items-center gap-2">
                <i class="fas fa-fire text-challenge-gold"></i> 習慣・記録
            </h2>

            <!-- タブナビゲーション -->
            <div class="flex mb-4 bg-gray-800 rounded-lg p-1 border border-gray-700">
                <button onclick="switchHabitTab('tab-study-time')" id="btn-tab-study-time"
                    class="flex-1 py-2 rounded-md text-xs font-bold text-gray-400 hover:text-white transition-all">
                    <i class="fas fa-stopwatch text-blue-400 mr-1"></i> 勉強時間
                </button>
                <button onclick="switchHabitTab('tab-habit-check')" id="btn-tab-habit-check"
                    class="flex-1 py-2 rounded-md text-xs font-bold text-white bg-gray-700 shadow transition-all">
                    <i class="fas fa-check-square text-challenge-gold mr-1"></i> チェック
                </button>
                <button onclick="switchHabitTab('tab-life-rhythm')" id="btn-tab-life-rhythm"
                    class="flex-1 py-2 rounded-md text-xs font-bold text-gray-400 hover:text-white transition-all">
                    <i class="fas fa-bed text-purple-400 mr-1"></i> 生活リズム
                </button>
            </div>

            <!-- タブ: 習慣チェック表 -->
            <div id="tab-habit-check" class="bg-app-panel border border-gray-700 rounded-lg p-4 mb-4">
                <div class="overflow-x-auto mb-4">
                    <div id="challenge-matrix-container" class="min-w-[320px]"></div>
                </div>
                <h3 class="text-xs font-bold text-gray-500 mb-2 uppercase">継続ステータス</h3>
                <div id="challenge-stats-grid" class="grid grid-cols-2 gap-3"></div>
            </div>

            <!-- タブ: 勉強時間 -->
            <div id="tab-study-time" class="bg-app-panel border border-gray-700 rounded-lg p-4 mb-4 hidden">
                <!-- 入力エリア -->
                <div class="bg-gray-800/50 rounded-lg p-3 mb-4 border border-gray-700">
                    <div class="flex items-center justify-between mb-4 bg-gray-900 rounded border border-gray-700 p-1">
                        <button onclick="shiftStudyLogDate(-1)"
                            class="w-8 h-8 flex items-center justify-center text-gray-400 hover:text-white hover:bg-gray-700 rounded transition-colors"><i
                                class="fas fa-chevron-left"></i></button>
                        <input type="date" id="study-log-date"
                            class="bg-transparent text-white text-xs font-bold text-center outline-none"
                            onchange="loadStudyLogDate()">
                        <button onclick="shiftStudyLogDate(1)"
                            class="w-8 h-8 flex items-center justify-center text-gray-400 hover:text-white hover:bg-gray-700 rounded transition-colors"><i
                                class="fas fa-chevron-right"></i></button>
                    </div>
                    <div class="flex items-end gap-2">
                        <div class="flex-1">
                            <label id="study-time-label" class="text-[10px] text-gray-500 block mb-1">今日の勉強時間</label>
                            <div class="flex gap-2 items-center">
                                <select id="study-log-hours"
                                    class="w-16 bg-gray-900 border-b border-gray-600 text-white text-lg font-mono focus:border-app-accent outline-none text-right appearance-none">
                                    <!-- Options generated by JS -->
                                </select>
                                <span class="text-xs text-gray-400">時間</span>
                                <select id="study-log-minutes"
                                    class="w-16 bg-gray-900 border-b border-gray-600 text-white text-lg font-mono focus:border-app-accent outline-none text-right appearance-none">
                                    <!-- Options generated by JS -->
                                </select>
                                <span class="text-xs text-gray-400">分</span>
                            </div>
                        </div>
                        <button onclick="saveStudyLog()"
                            class="bg-blue-600 hover:bg-blue-500 text-white text-[10px] font-bold px-4 py-2 rounded mb-1 whitespace-nowrap shadow-md">保存</button>
                    </div>
                </div>

                <!-- グラフエリア -->
                <div class="bg-app-panel rounded-lg border border-gray-700 p-2">
                    <div class="flex justify-between items-center mb-2">
                        <div class="flex gap-2">
                            <button onclick="changeStudyChartRange(7)"
                                class="study-chart-range-btn text-[10px] px-2 py-0.5 rounded bg-gray-700 text-white transition-colors"
                                data-range="7">1週</button>
                            <button onclick="changeStudyChartRange(14)"
                                class="study-chart-range-btn text-[10px] px-2 py-0.5 rounded text-gray-400 hover:bg-gray-800 transition-colors"
                                data-range="14">2週</button>
                            <button onclick="changeStudyChartRange(30)"
                                class="study-chart-range-btn text-[10px] px-2 py-0.5 rounded text-gray-400 hover:bg-gray-800 transition-colors"
                                data-range="30">1ヶ月</button>
                        </div>
                        <div class="text-[9px] text-gray-500">合計: <span id="study-total-display"
                                class="font-bold text-white">0h 0m</span> (期間内)</div>
                    </div>
                    <div class="relative w-full h-48 bg-gray-900/50 rounded overflow-hidden">
                        <canvas id="studyTimeChart"></canvas>
                    </div>
                </div>
            </div>

            <!-- タブ: 生活リズム -->
            <div id="tab-life-rhythm" class="bg-app-panel border border-gray-700 rounded-lg p-4 mb-4 hidden">
                <!-- 入力エリア -->
                <div class="bg-gray-800/50 rounded-lg p-3 mb-4 border border-gray-700">
                    <div class="flex items-center justify-between mb-4 bg-gray-900 rounded border border-gray-700 p-1">
                        <button onclick="shiftSleepLogDate(-1)"
                            class="w-8 h-8 flex items-center justify-center text-gray-400 hover:text-white hover:bg-gray-700 rounded transition-colors"><i
                                class="fas fa-chevron-left"></i></button>
                        <input type="date" id="sleep-log-date"
                            class="bg-transparent text-white text-xs font-bold text-center outline-none"
                            onchange="loadSleepLogDate()">
                        <button onclick="shiftSleepLogDate(1)"
                            class="w-8 h-8 flex items-center justify-center text-gray-400 hover:text-white hover:bg-gray-700 rounded transition-colors"><i
                                class="fas fa-chevron-right"></i></button>
                    </div>
                    <div class="flex flex-col gap-3">
                        <div class="flex items-end gap-2">
                            <div class="flex-1">
                                <label class="text-[10px] text-gray-500 block mb-1">起床</label>
                                <input type="time" id="sleep-log-wake"
                                    class="w-full bg-gray-900 border-b border-gray-600 text-white text-lg font-mono focus:border-app-accent outline-none">
                            </div>
                            <button onclick="saveSleepLog('wake')"
                                class="bg-yellow-600 hover:bg-yellow-500 text-white text-[10px] font-bold px-3 py-2 rounded mb-1 whitespace-nowrap shadow-md">起床記録</button>
                        </div>
                        <div class="flex items-end gap-2">
                            <div class="flex-1">
                                <label class="text-[10px] text-gray-500 block mb-1">就寝 (深夜は28時まで対応)</label>
                                <input type="time" id="sleep-log-bed"
                                    class="w-full bg-gray-900 border-b border-gray-600 text-white text-lg font-mono focus:border-app-accent outline-none">
                            </div>
                            <button onclick="saveSleepLog('bed')"
                                class="bg-purple-600 hover:bg-purple-500 text-white text-[10px] font-bold px-3 py-2 rounded mb-1 whitespace-nowrap shadow-md">就寝記録</button>
                        </div>
                    </div>
                </div>

                <!-- グラフエリア -->
                <div class="bg-app-panel rounded-lg border border-gray-700 p-2">
                    <div class="flex justify-end gap-2 mb-2">
                        <button onclick="changeSleepChartRange(7)"
                            class="chart-range-btn text-[10px] px-2 py-0.5 rounded bg-gray-700 text-white transition-colors"
                            data-range="7">1週</button>
                        <button onclick="changeSleepChartRange(14)"
                            class="chart-range-btn text-[10px] px-2 py-0.5 rounded text-gray-400 hover:bg-gray-800 transition-colors"
                            data-range="14">2週</button>
                        <button onclick="changeSleepChartRange(30)"
                            class="chart-range-btn text-[10px] px-2 py-0.5 rounded text-gray-400 hover:bg-gray-800 transition-colors"
                            data-range="30">1ヶ月</button>
                    </div>
                    <div class="relative w-full h-48 bg-gray-900/50 rounded overflow-hidden" id="sleep-chart-container">
                        <svg id="sleep-chart-svg" width="100%" height="100%" class="w-full h-full block"></svg>
                    </div>
                    <div class="flex justify-center gap-4 mt-2 text-[10px]">
                        <span class="flex items-center gap-1"><span class="w-2 h-2 rounded-full bg-purple-400"></span>
                            就寝</span>
                        <span class="flex items-center gap-1"><span class="w-2 h-2 rounded-full bg-yellow-400"></span>
                            起床</span>
                    </div>
                </div>
            </div>
        </div>

        <div id="manage-screen" class="tab-content p-4 pb-32">
            <h2 class="text-lg font-bold text-white mb-4">科目・チャレンジ管理</h2>
            <div id="manage-subject-list" class="space-y-4"></div>
            <div class="mt-4 border-t border-gray-700 pt-4 space-y-4">
                <div>
                    <label class="text-[10px] font-bold text-gray-400 mb-1 block">学習科目の追加</label>
                    <div class="flex gap-2">
                        <input type="text" id="new-subject-name" placeholder="新しい科目名"
                            class="flex-1 bg-gray-900 border border-gray-700 text-white text-xs rounded px-3 py-2">
                        <button onclick="addNewSubject('study')"
                            class="bg-app-accent text-app-dark text-xs font-bold px-4 py-2 rounded hover:bg-sky-300">追加</button>
                    </div>
                </div>
                <div>
                    <label class="text-[10px] font-bold text-gray-400 mb-1 block">継続チャレンジの追加</label>
                    <div class="flex gap-2">
                        <input type="text" id="new-challenge-name" placeholder="チャレンジ名"
                            class="flex-1 bg-gray-900 border border-gray-700 text-white text-xs rounded px-3 py-2">
                        <button onclick="addNewSubject('challenge')"
                            class="bg-challenge-gold text-app-dark text-xs font-bold px-4 py-2 rounded hover:bg-yellow-400">追加</button>
                    </div>
                </div>
            </div>
            <div id="unit-editor-area"
                class="fixed inset-0 bg-black/80 backdrop-blur-sm z-[150] hidden flex items-center justify-center p-4">
                <div
                    class="bg-app-panel border border-gray-600 rounded-lg w-full max-w-lg p-5 shadow-2xl max-h-[90vh] flex flex-col overflow-hidden">

                    <div class="flex justify-between items-center mb-4 border-b border-gray-700 pb-2 shrink-0">
                        <h3 class="text-lg font-bold text-white">科目・単元編集</h3>
                        <button onclick="closeUnitEditor()" class="text-gray-400 hover:text-white"><i
                                class="fas fa-times text-xl"></i></button>
                    </div>

                    <div class="overflow-y-auto flex-1 pr-1 custom-scrollbar">

                        <div class="mb-6">
                            <label class="text-[10px] text-gray-500 block mb-1">科目名を変更</label>
                            <div class="flex gap-2">
                                <input type="text" id="edit-subject-name-input"
                                    class="flex-1 bg-gray-900 border border-gray-700 text-white text-sm rounded px-3 py-2">
                                <button onclick="updateSubjectName()"
                                    class="bg-app-accent text-app-dark text-xs font-bold px-4 rounded hover:bg-sky-300">変更</button>
                            </div>
                        </div>

                        <div class="bg-gray-800/50 rounded border border-gray-700 p-3 mb-4">
                            <label class="text-[10px] text-gray-400 block mb-2 font-bold">単元の追加・編集</label>

                            <div class="flex flex-col gap-2 mb-2">
                                <div class="flex gap-2">
                                    <input type="text" id="new-unit-category" placeholder="カテゴリ"
                                        class="w-1/3 bg-gray-900 border border-gray-700 text-white text-xs rounded px-2 py-2">
                                    <input type="text" id="new-unit-title" placeholder="単元名"
                                        class="flex-1 bg-gray-900 border border-gray-700 text-white text-xs rounded px-2 py-2">
                                </div>

                                <div class="flex gap-2 items-center">
                                    <select id="new-unit-status-select"
                                        class="bg-gray-900 border border-gray-700 text-white text-xs rounded px-2 py-2 focus:border-app-accent">
                                        <option value="pending">未完了</option>
                                        <option value="completed">完了 (今日)</option>
                                        <option value="completed_init" class="text-yellow-400">完了 (元々/0日目)</option>
                                    </select>

                                    <div
                                        class="flex items-center gap-1 bg-gray-900 border border-gray-700 rounded px-2 py-2">
                                        <span class="text-[10px] text-gray-500">周回:</span>
                                        <input type="number" id="new-unit-lap" value="0" min="0"
                                            class="w-10 bg-transparent text-white text-xs text-right outline-none">
                                    </div>

                                    <label class="flex items-center cursor-pointer">
                                        <input type="checkbox" id="new-unit-weak" class="hidden weak-checkbox">
                                        <div
                                            class="text-[10px] text-gray-500 bg-gray-900 border border-gray-700 px-3 py-2 rounded select-none hover:bg-gray-800 transition-colors flex items-center gap-1">
                                            <i class="fas fa-exclamation-triangle"></i>
                                        </div>
                                    </label>

                                    <button id="add-update-unit-btn" onclick="saveUnit()"
                                        class="bg-gray-700 text-white text-xs px-3 py-2 rounded hover:bg-gray-600 flex-1 font-bold">追加</button>
                                    <button id="cancel-edit-unit-btn" onclick="cancelEditUnit()"
                                        class="bg-red-900/50 text-red-200 text-xs px-2 py-2 rounded hover:bg-red-900 hidden"><i
                                            class="fas fa-times"></i></button>
                                </div>
                            </div>
                        </div>

                        <div
                            class="flex items-center justify-between mb-2 p-3 bg-gray-800 rounded border border-gray-700 sticky top-0 z-10 shadow-md">
                            <label
                                class="flex items-center gap-2 cursor-pointer text-xs text-gray-300 font-bold select-none">
                                <input type="checkbox" id="select-all-units" onchange="toggleAllUnitChecks(this)"
                                    class="accent-app-accent w-4 h-4">
                                全て選択
                            </label>

                            <button onclick="openBulkEditModal()"
                                class="bg-app-accent text-app-dark text-xs font-bold px-4 py-2 rounded hover:bg-sky-300 shadow-sm flex items-center gap-2 transition-transform active:scale-95">
                                <i class="fas fa-pen-to-square"></i> 選択した単元を編集
                            </button>
                        </div>

                        <!-- Modals moved to root -->

                        <div id="manage-unit-list" class="space-y-1 pb-4"></div>
                    </div>
                </div>
            </div>
            <div id="challenge-editor-area"
                class="fixed inset-0 bg-black/80 backdrop-blur-sm z-[150] hidden flex items-center justify-center p-4">
                <div
                    class="bg-app-panel border border-gray-600 rounded-lg w-full max-w-sm p-5 shadow-2xl flex flex-col">

                    <div class="flex justify-between items-center mb-4 border-b border-gray-700 pb-2">
                        <h3 class="text-lg font-bold text-white">チャレンジ設定</h3>
                        <button onclick="closeChallengeEditor()" class="text-gray-400 hover:text-white"><i
                                class="fas fa-times text-xl"></i></button>
                    </div>

                    <div class="space-y-4">
                        <div>
                            <label class="text-[10px] text-gray-500 block mb-1">チャレンジ名</label>
                            <input type="text" id="edit-challenge-name"
                                class="w-full bg-gray-900 border border-gray-700 text-white text-sm rounded px-3 py-2 focus:border-app-accent outline-none">
                        </div>

                        <div class="grid grid-cols-2 gap-3">
                            <div>
                                <label class="text-[10px] text-gray-500 block mb-1">開始日</label>
                                <input type="date" id="edit-challenge-start"
                                    class="w-full bg-gray-900 border border-gray-700 text-white text-xs rounded px-2 py-2 focus:border-app-accent outline-none">
                            </div>
                            <div>
                                <label class="text-[10px] text-gray-500 block mb-1">目標日</label>
                                <input type="date" id="edit-challenge-end"
                                    class="w-full bg-gray-900 border border-gray-700 text-white text-xs rounded px-2 py-2 focus:border-app-accent outline-none">
                            </div>
                        </div>

                        <div class="pt-2 border-t border-gray-700 mt-2">
                            <label class="text-[10px] text-gray-500 block mb-1">自動チェック連携 (生活リズム)</label>
                            <div class="mb-4">
                                <label class="text-xs text-gray-500 block mb-1">自動チェック条件 (オプション)</label>
                                <select id="edit-challenge-auto-type"
                                    class="w-full bg-gray-900 border border-gray-700 rounded p-2 text-white text-xs mb-2"
                                    onchange="toggleAutoTimeInput()">
                                    <option value="">なし (手動チェック)</option>
                                    <option value="waketime">起床時間 (これより早い)</option>
                                    <option value="bedtime">就寝時間 (これより早い)</option>
                                    <option value="study_time">勉強時間 (これ以上)</option> <!-- ★追加 -->
                                </select>

                                <div id="auto-time-input-area" class="hidden">
                                    <label class="text-xs text-gray-500 block mb-1">目標値 (時間または分)</label>
                                    <div class="flex items-center gap-2">
                                        <input type="text" id="edit-challenge-target-time"
                                            class="flex-1 bg-gray-900 border border-gray-700 text-white text-xs rounded p-2"
                                            placeholder="07:00 または 60">
                                        <span class="text-[10px] text-gray-400" id="auto-time-unit-label"></span>
                                    </div>
                                    <p class="text-[10px] text-gray-500 mt-1" id="auto-time-help-text">
                                        ※起床・就寝は「HH:MM」、勉強時間は「分」で入力
                                    </p>
                                </div>
                            </div>

                            <div class="pt-2">
                                <button onclick="saveChallengeSettings()"
                                    class="w-full bg-challenge-gold text-app-dark text-sm font-bold py-2.5 rounded hover:bg-yellow-400 transition-colors shadow-md">
                                    設定を保存
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div id="gemini-import-area" class="mb-6 border-t border-gray-700 pt-6">
                <h3 class="text-xs font-bold text-gray-400 mb-2 uppercase flex items-center gap-2"><i
                        class="fas fa-robot text-purple-400"></i> AIで科目追加 (Gemini)</h3>
                <div class="bg-gray-800/50 p-3 rounded border border-gray-700 mb-3">
                    <div class="relative">
                        <textarea id="gemini-prompt-template"
                            class="w-full bg-gray-900 border border-gray-700 text-gray-300 text-[10px] rounded p-2 h-20"
                            readonly>「[科目名]」という科目の学習進捗管理用のデータをJSON形式で作成してください。
形式:
{
  "name": "[科目名]",
  "syllabus": [
    {"category": "カテゴリ名", "title": "単元名1"},
    {"category": "カテゴリ名", "title": "単元名2"}
  ]
}
※syllabusの各要素のcategoryとtitleは日本語で作成してください。</textarea>
                        <button onclick="copyPrompt()"
                            class="absolute top-1 right-1 bg-gray-700 hover:bg-gray-600 text-white text-[10px] px-2 py-1 rounded">コピー</button>
                    </div>
                </div>
                <div class="flex gap-2">
                    <input type="text" id="gemini-json-input" placeholder='Geminiの出力JSONをここに貼り付け'
                        class="flex-1 bg-gray-900 border border-gray-700 text-white text-xs rounded px-3 py-2">
                    <button onclick="importFromGemini()"
                        class="bg-purple-600 hover:bg-purple-500 text-white text-xs font-bold px-4 py-2 rounded">取り込み</button>
                </div>
            </div>

            <div class="mt-8 border-t border-gray-700 pt-6">
                <h3 class="text-sm font-bold text-gray-400 mb-4 flex items-center gap-2">
                    <i class="fas fa-bullhorn text-orange-400"></i> 学習ティッカー設定
                </h3>

                <div class="bg-gray-800/50 rounded border border-gray-700 p-4 mb-4">
                    <div class="flex justify-between items-center mb-4 border-b border-gray-700 pb-2">
                        <label class="text-xs font-bold text-gray-300">ティッカー表示</label>
                        <label class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="ticker-enabled-toggle" class="sr-only peer"
                                onchange="toggleTickerEnabled()">
                            <div
                                class="w-11 h-6 bg-gray-600 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-800 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600">
                            </div>
                        </label>
                    </div>

                    <div class="flex justify-between items-center mb-2">
                        <label class="text-xs font-bold text-gray-300">カテゴリ一覧</label>
                        <div class="flex gap-2">
                            <button onclick="openBulkWeightEditor()"
                                class="text-[10px] text-sky-400 hover:text-sky-300 underline">重み一括編集</button>
                            <button onclick="resetTickerData()"
                                class="text-[10px] text-red-400 hover:text-red-300 underline">初期化</button>
                        </div>
                    </div>
                    <div id="ticker-category-list" class="space-y-2 mb-4"></div>
                    <button onclick="addNewTickerCategory()"
                        class="w-full py-2 bg-gray-700 hover:bg-gray-600 text-white text-xs font-bold rounded border border-gray-600 mb-4"><i
                            class="fas fa-plus"></i> カテゴリを追加</button>

                    <label class="text-xs font-bold text-gray-300 block mb-2">データ一括インポート (JSON)</label>
                    <div class="relative mb-2">
                        <textarea id="ticker-json-input"
                            class="w-full bg-gray-900 border border-gray-700 text-gray-300 text-[10px] rounded p-2 h-20 font-mono"
                            placeholder='{"categories": [...], "messages": [...]}'></textarea>
                        <button onclick="copyTickerPrompt()"
                            class="absolute top-1 right-1 bg-gray-700 hover:bg-gray-600 text-white text-[10px] px-2 py-1 rounded flex items-center gap-1">
                            コピー
                        </button>
                    </div>
                    <div class="flex justify-end">
                        <button onclick="importTickerData()"
                            class="bg-app-accent text-app-dark text-xs font-bold px-4 py-2 rounded hover:bg-sky-300">
                            追加インポート
                        </button>
                    </div>
                </div>
                <div class="text-[10px] text-gray-500 text-right">
                    登録メッセージ数: <span id="ticker-msg-count">0</span> 件
                </div>
            </div>

            <div id="ticker-category-editor"
                class="fixed inset-0 bg-black/80 backdrop-blur-sm z-[200] hidden flex items-center justify-center p-4">
                <div
                    class="bg-app-panel border border-gray-600 rounded-lg w-full max-w-md p-5 shadow-2xl flex flex-col max-h-[90vh]">
                    <div class="flex justify-between items-center mb-4 border-b border-gray-700 pb-2">
                        <h3 class="text-lg font-bold text-white">カテゴリ編集</h3>
                        <button onclick="closeTickerCategoryEditor()" class="text-gray-400 hover:text-white"><i
                                class="fas fa-times text-xl"></i></button>
                    </div>

                    <div class="overflow-y-auto flex-1 pr-1 custom-scrollbar">
                        <div class="space-y-4 mb-6">
                            <div>
                                <label class="text-[10px] text-gray-500 block mb-1">カテゴリ名</label>
                                <input type="text" id="edit-ticker-cat-name"
                                    class="w-full bg-gray-900 border border-gray-700 text-white text-xs rounded px-3 py-2">
                            </div>

                            <div>
                                <label class="text-[10px] text-gray-500 block mb-2">カラー</label>
                                <div id="edit-ticker-cat-color-palette" class="grid grid-cols-8 gap-2">
                                </div>
                                <input type="hidden" id="edit-ticker-cat-color-value">
                            </div>

                            <div>
                                <label class="text-[10px] text-gray-500 block mb-1">出現重み: <span
                                        id="edit-ticker-cat-weight-value" class="font-bold text-white">10</span></label>
                                <input type="range" id="edit-ticker-cat-weight" min="1" max="20"
                                    class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                            </div>

                            <button onclick="saveTickerCategoryInfo()"
                                class="w-full bg-gray-700 hover:bg-gray-600 text-white text-xs font-bold py-2 rounded border border-gray-600">設定を更新</button>
                        </div>

                        <div class="border-t border-gray-700 pt-4">
                            <label class="text-xs font-bold text-gray-300 block mb-2">メッセージリスト</label>
                            <div class="flex gap-2 mb-2">
                                <input type="text" id="new-ticker-msg-input" placeholder="新しいメッセージ"
                                    class="flex-1 bg-gray-900 border border-gray-700 text-white text-xs rounded px-3 py-2">
                                <button onclick="addTickerMessageInEditor()"
                                    class="bg-app-accent text-app-dark text-xs font-bold px-3 py-2 rounded hover:bg-sky-300">追加</button>
                            </div>
                            <div id="editor-ticker-msg-list"
                                class="space-y-1 bg-gray-900 p-2 rounded border border-gray-700 min-h-[150px]">
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ティッカー重み一括編集モーダル -->
            <div id="ticker-bulk-weight-editor"
                class="fixed inset-0 bg-black/80 backdrop-blur-sm z-[210] hidden flex items-center justify-center p-4">
                <div
                    class="bg-app-panel border border-gray-600 rounded-lg w-full max-w-md p-5 shadow-2xl flex flex-col max-h-[90vh]">
                    <div class="flex justify-between items-center mb-4 border-b border-gray-700 pb-2">
                        <h3 class="text-lg font-bold text-white">重み一括編集</h3>
                        <button onclick="closeBulkWeightEditor()" class="text-gray-400 hover:text-white"><i
                                class="fas fa-times text-xl"></i></button>
                    </div>

                    <div id="bulk-weight-list" class="overflow-y-auto flex-1 pr-1 custom-scrollbar space-y-3 mb-4">
                        <!-- ここにスライダーが動的に生成される -->
                    </div>

                    <div class="flex gap-2">
                        <button onclick="closeBulkWeightEditor()"
                            class="flex-1 bg-gray-800 text-gray-300 text-xs font-bold py-2.5 rounded border border-gray-600 hover:bg-gray-700">キャンセル</button>
                        <button onclick="saveBulkWeights()"
                            class="flex-1 bg-app-accent text-app-dark text-xs font-bold py-2.5 rounded hover:bg-sky-300 shadow-md">
                            保存する
                        </button>
                    </div>
                </div>
            </div>
        </div>

    </main>

    <nav id="app-nav"
        class="fixed bottom-0 left-0 w-full bg-app-panel/95 backdrop-blur-md border-t border-gray-700 flex justify-between items-end h-16 shrink-0 z-50 px-1 overflow-visible">

        <button
            class="nav-btn flex-1 flex flex-col items-center justify-center pb-2 h-full text-gray-500 hover:text-white transition-colors"
            data-target="home-screen">
            <i class="fas fa-chart-pie text-lg mb-1"></i><span
                class="text-[9px] font-medium tracking-tighter">ホーム</span>
        </button>

        <button
            class="nav-btn flex-1 flex flex-col items-center justify-center pb-2 h-full text-gray-500 hover:text-white transition-colors"
            data-target="calendar-screen">
            <i class="far fa-calendar-alt text-lg mb-1"></i><span
                class="text-[9px] font-medium tracking-tighter">カレンダー</span>
        </button>

        <div class="nav-center-wrapper">
            <button class="nav-center-btn" onclick="switchTab('record-screen')">
                <i class="fas fa-pencil-alt"></i><span>記録</span>
            </button>
        </div>

        <button
            class="nav-btn flex-1 flex flex-col items-center justify-center pb-2 h-full text-gray-500 hover:text-white transition-colors"
            data-target="challenge-screen">
            <i class="fas fa-fire text-lg mb-1"></i><span class="text-[9px] font-medium tracking-tighter">習慣</span>
        </button>

        <button
            class="nav-btn flex-1 flex flex-col items-center justify-center pb-2 h-full text-gray-500 hover:text-white transition-colors"
            data-target="manage-screen">
            <i class="fas fa-sliders-h text-lg mb-1"></i><span class="text-[9px] font-medium tracking-tighter">管理</span>
        </button>
    </nav>

    <div id="date-modal"
        class="fixed inset-0 bg-black/80 backdrop-blur-sm z-[100] hidden flex items-center justify-center p-4">
        <div
            class="bg-app-panel border border-gray-600 rounded-lg w-full max-w-sm p-5 shadow-2xl flex flex-col max-h-[90vh]">
            <div class="flex justify-between items-center mb-4 border-b border-gray-700 pb-2">
                <h3 id="modal-date-title" class="text-lg font-bold text-white"></h3>
                <button onclick="closeModal()" class="text-gray-400 hover:text-white"><i
                        class="fas fa-times text-xl"></i></button>
            </div>
            <div class="mb-4 overflow-y-auto flex-1">
                <div id="modal-study-content">
                    <button id="set-exam-btn"
                        class="w-full py-2 px-3 bg-gray-700 hover:bg-gray-600 text-yellow-400 rounded text-xs font-bold mb-4 flex items-center justify-center gap-2 border border-gray-600 shadow-sm">
                        <i class="fas fa-flag"></i> <span id="exam-btn-text">目標日に設定</span>
                    </button>
                    <h4
                        class="text-xs text-app-success mb-2 font-bold uppercase tracking-wider flex items-center gap-1">
                        <i class="fas fa-check-circle"></i> 完了実績
                    </h4>
                    <div id="modal-completed-list"
                        class="bg-gray-900/50 rounded border border-gray-700 mb-4 p-2 text-sm text-gray-400 min-h-[40px]">
                    </div>
                    <h4 class="text-xs text-gray-400 mb-2 font-bold uppercase tracking-wider">学習予定</h4>
                    <div id="modal-task-list" class="bg-gray-900 rounded border border-gray-700 mb-2"></div>
                    <div class="flex gap-2 items-center border-t border-gray-700 pt-2 mt-2">
                        <div class="relative flex-1 min-w-0">
                            <select id="unit-selector"
                                class="w-full bg-gray-900 border border-gray-700 text-white text-xs rounded px-2 py-2 appearance-none focus:outline-none focus:border-app-accent truncate pr-6 cursor-pointer">
                            </select>
                            <div
                                class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-400">
                                <i class="fas fa-chevron-down text-[10px]"></i>
                            </div>
                        </div>
                        <button onclick="addUnitToDate()"
                            class="bg-app-accent text-app-dark font-bold px-3 py-2 rounded hover:bg-sky-300 shrink-0 flex items-center justify-center">
                            <i class="fas fa-plus"></i>
                        </button>
                    </div>
                </div>
                <div id="modal-challenge-content" class="hidden">
                    <p class="text-sm text-gray-300 mb-4" id="modal-challenge-status">この日のチャレンジ記録:</p>
                    <button id="toggle-challenge-date-btn"
                        class="w-full py-3 rounded-lg font-bold text-sm shadow-md"></button>
                </div>
            </div>
            <button onclick="closeModal()"
                class="w-full py-2 bg-gray-800 hover:bg-gray-700 text-gray-300 rounded text-sm border border-gray-600">閉じる</button>
        </div>
    </div>

    <div id="settings-modal"
        class="fixed inset-0 bg-black/80 backdrop-blur-sm z-[120] hidden flex items-center justify-center p-4">
        <div class="bg-app-panel border border-gray-600 rounded-lg w-full max-w-sm p-5 shadow-2xl">
            <div class="flex justify-between items-center mb-4 border-b border-gray-700 pb-2">
                <div class="flex items-baseline gap-2">
                    <h3 class="text-lg font-bold text-white">設定</h3>
                    <span id="app-version-display" class="text-[10px] text-gray-500 font-mono">v1.0.0</span>
                </div>
                <button onclick="closeSettingsModal()" class="text-gray-400 hover:text-white"><i
                        class="fas fa-times text-xl"></i></button>
            </div>
            <div class="space-y-6">
                <div>
                    <h4 class="text-xs font-bold text-gray-400 mb-2 uppercase tracking-widest">表示設定</h4>
                    <button id="theme-toggle-btn" onclick="toggleTheme()"
                        class="w-full py-2 bg-gray-700 hover:bg-gray-600 text-white rounded text-xs flex items-center justify-center gap-2 border border-gray-600">
                        <i class="fas fa-moon"></i> <span>ダークモード中</span>
                    </button>
                </div>
                <div>
                    <h4 class="text-xs font-bold text-gray-400 mb-2 uppercase tracking-widest">アカウント</h4>
                    <button onclick="firebase.auth().signOut()"
                        class="w-full py-2 bg-gray-700 hover:bg-gray-600 text-white rounded text-xs mb-2">ログアウト</button>
                </div>

                <div>
                    <h4 class="text-xs font-bold text-gray-400 mb-2 uppercase tracking-widest">データ管理</h4>
                    <div class="text-[10px] text-app-success mb-2">※データはクラウドに自動保存されています</div>

                    <div class="flex flex-col gap-2">
                        <button onclick="exportToGoogleSheets()"
                            class="w-full py-2.5 bg-green-700 hover:bg-green-600 text-white rounded text-xs font-bold border border-green-500 flex items-center justify-center gap-2 transition-colors">
                            <i class="fas fa-table"></i> Gemini分析用シートを作成 (スプレッドシート)
                        </button>

                        <div class="flex gap-2">
                            <button onclick="exportData()"
                                class="flex-1 py-2.5 bg-app-panel border border-app-accent text-app-accent rounded text-xs font-bold hover:bg-app-accent/10"><i
                                    class="fas fa-download"></i> JSONバックアップ</button>
                            <button onclick="document.getElementById('import-file').click()"
                                class="flex-1 py-2.5 bg-app-panel border border-gray-600 text-gray-300 rounded text-xs font-bold hover:bg-gray-700"><i
                                    class="fas fa-upload"></i> 復元</button>
                            <input type="file" id="import-file" class="hidden" accept=".json"
                                onchange="importData(this)">
                        </div>
                    </div>
                </div>
                <div class="pt-2 border-t border-gray-800">
                    <button onclick="location.reload(true)"
                        class="w-full py-2 text-[10px] text-gray-500 hover:text-white mb-2">最新バージョンを再読み込み
                        (強制リロード)</button>
                    <button onclick="requestReset()"
                        class="w-full py-2 text-[10px] text-red-400 opacity-50 hover:opacity-100">データをリセット</button>
                </div>
            </div>
        </div>
    </div>

    <div id="app-modal"
        class="fixed inset-0 bg-black/80 backdrop-blur-md z-[200] hidden flex items-center justify-center p-6">
        <div id="custom-alert-box"
            class="bg-app-panel border border-gray-600 rounded-xl w-full max-w-xs p-6 shadow-2xl">
            <h3 id="app-modal-title" class="text-lg font-bold text-white mb-3">確認</h3>
            <p id="app-modal-body" class="text-sm text-gray-300 mb-6 leading-relaxed"></p>
            <div id="app-modal-footer" class="flex gap-3">
                <button id="app-modal-cancel"
                    class="flex-1 py-2 bg-gray-800 text-gray-400 rounded-lg text-sm font-bold border border-gray-700">キャンセル</button>
                <button id="app-modal-ok"
                    class="flex-1 py-2 bg-red-600 text-white rounded-lg text-sm font-bold shadow-lg">実行する</button>
            </div>
        </div>
    </div>

    <div id="bulk-edit-modal"
        class="fixed inset-0 bg-black/80 backdrop-blur-sm z-[200] hidden flex items-center justify-center p-4">
        <div class="bg-app-panel border border-gray-600 rounded-lg w-full max-w-sm p-5 shadow-2xl flex flex-col">
            <div class="flex justify-between items-center mb-4 border-b border-gray-700 pb-2">
                <h3 class="text-lg font-bold text-white">一括編集</h3>
                <button onclick="closeBulkEditModal()" class="text-gray-400 hover:text-white"><i
                        class="fas fa-times text-xl"></i></button>
            </div>

            <div class="space-y-5">
                <div class="bg-app-accent/10 border border-app-accent/20 rounded p-2 text-center">
                    <span id="bulk-selected-count" class="text-app-accent font-bold text-sm">0</span>
                    <span class="text-xs text-gray-400">件の単元を選択中</span>
                </div>

                <div>
                    <label class="text-[10px] text-gray-500 block mb-1 font-bold">カテゴリを変更</label>
                    <input type="text" id="bulk-edit-category" placeholder="変更しない場合は空欄"
                        class="w-full bg-gray-900 border border-gray-700 text-white text-xs rounded px-3 py-2">
                </div>

                <div>
                    <label class="text-[10px] text-gray-500 block mb-1 font-bold">ステータス・完了日</label>
                    <div class="flex flex-col gap-2">
                        <select id="bulk-edit-status"
                            class="w-full bg-gray-900 border border-gray-700 text-white text-xs rounded px-3 py-2"
                            onchange="toggleBulkDateInputInModal()">
                            <option value="no-change">変更しない</option>
                            <option value="pending">未完了に戻す</option>
                            <option value="completed">完了 (今日)</option>
                            <option value="completed_date">完了 (日付を指定)</option>
                            <option value="initial">既遂 (0日目) にする</option>
                        </select>
                        <input type="date" id="bulk-edit-date"
                            class="hidden w-full bg-gray-900 border border-gray-700 text-white text-xs rounded px-3 py-2">
                    </div>
                </div>

                <div>
                    <label class="text-[10px] text-gray-500 block mb-1 font-bold">周回数</label>
                    <input type="number" id="bulk-edit-lap" placeholder="変更しない場合は空欄" min="0"
                        class="w-full bg-gray-900 border border-gray-700 text-white text-xs rounded px-3 py-2">
                </div>

                <div class="pt-2 flex gap-2">
                    <button onclick="closeBulkEditModal()"
                        class="flex-1 bg-gray-800 text-gray-300 text-xs font-bold py-2.5 rounded border border-gray-600 hover:bg-gray-700">キャンセル</button>
                    <button onclick="applyCombinedBulkEdit()"
                        class="flex-1 bg-app-accent text-app-dark text-xs font-bold py-2.5 rounded hover:bg-sky-300 shadow-md">
                        変更を適用
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div id="single-unit-edit-modal"
        class="fixed inset-0 bg-black/80 backdrop-blur-sm z-[200] hidden flex items-center justify-center p-4">
        <div class="bg-app-panel border border-gray-600 rounded-lg w-full max-w-sm p-5 shadow-2xl flex flex-col">
            <div class="flex justify-between items-center mb-4 border-b border-gray-700 pb-2">
                <h3 class="text-lg font-bold text-white">単元の編集</h3>
                <button onclick="closeSingleUnitEditModal()" class="text-gray-400 hover:text-white"><i
                        class="fas fa-times text-xl"></i></button>
            </div>

            <div class="space-y-4">
                <div class="flex gap-2">
                    <div class="w-1/3">
                        <label class="text-[10px] text-gray-500 block mb-1 font-bold">カテゴリ</label>
                        <input type="text" id="single-edit-category"
                            class="w-full bg-gray-900 border border-gray-700 text-white text-xs rounded px-3 py-2">
                    </div>
                    <div class="flex-1">
                        <label class="text-[10px] text-gray-500 block mb-1 font-bold">単元名</label>
                        <input type="text" id="single-edit-title"
                            class="w-full bg-gray-900 border border-gray-700 text-white text-xs rounded px-3 py-2">
                    </div>
                </div>

                <div class="flex items-end gap-2 justify-center mb-4">
                    <div class="flex flex-col items-center">
                        <label class="text-[10px] text-gray-500 mb-1 font-bold">時間</label>
                        <select id="study-log-hours"
                            class="bg-gray-800 border border-gray-600 text-white rounded px-4 py-2 text-xl font-mono text-center w-24">
                        </select>
                    </div>
                    <span class="text-white pb-3 font-bold">:</span>
                    <div class="flex flex-col items-center">
                        <label class="text-[10px] text-gray-500 mb-1 font-bold">分</label>
                        <!-- Infinite Scroll Picker Container -->
                        <div
                            class="relative w-24 h-[46px] bg-gray-800 border border-gray-600 rounded overflow-hidden group select-none">
                            <div id="study-log-minutes-scroll"
                                class="absolute inset-0 overflow-y-scroll scrollbar-hide snap-y snap-mandatory cursor-grab active:cursor-grabbing">
                                <!-- Options will be injected safely by JS -->
                            </div>
                            <!-- Highlight overlay -->
                            <div
                                class="pointer-events-none absolute inset-0 border-2 border-app-accent rounded opacity-50 bg-white/5">
                            </div>
                        </div>
                        <input type="hidden" id="study-log-minutes">
                    </div>
                </div>
                <div>
                    <label class="text-[10px] text-gray-500 block mb-1 font-bold">ステータス・完了日</label>
                    <div class="flex flex-col gap-2">
                        <select id="single-edit-status"
                            class="w-full bg-gray-900 border border-gray-700 text-white text-xs rounded px-3 py-2"
                            onchange="toggleSingleEditDateInput()">
                            <option value="pending">未完了</option>
                            <option value="completed">完了 (今日)</option>
                            <option value="completed_date">完了 (日付を指定)</option>
                            <option value="initial">既遂 (0日目)</option>
                        </select>
                        <input type="date" id="single-edit-date"
                            class="hidden w-full bg-gray-900 border border-gray-700 text-white text-xs rounded px-3 py-2">
                    </div>
                </div>

                <div class="flex gap-3">
                    <div class="flex-1">
                        <label class="text-[10px] text-gray-500 block mb-1 font-bold">周回数</label>
                        <input type="number" id="single-edit-lap" min="0"
                            class="w-full bg-gray-900 border border-gray-700 text-white text-xs rounded px-3 py-2">
                    </div>
                    <div class="flex-1 flex flex-col justify-end">
                        <label
                            class="flex items-center gap-2 cursor-pointer bg-gray-900 border border-gray-700 rounded px-3 py-2 hover:bg-gray-800 transition-colors h-[34px]">
                            <input type="checkbox" id="single-edit-weak" class="accent-app-weak">
                            <span class="text-xs text-gray-300 flex items-center gap-1"><i
                                    class="fas fa-exclamation-triangle text-app-weak"></i> 苦手</span>
                        </label>
                    </div>
                </div>

                <div class="pt-2 flex gap-2">
                    <button onclick="closeSingleUnitEditModal()"
                        class="flex-1 bg-gray-800 text-gray-300 text-xs font-bold py-2.5 rounded border border-gray-600 hover:bg-gray-700">キャンセル</button>
                    <button onclick="saveSingleUnitEdit()"
                        class="flex-1 bg-app-accent text-app-dark text-xs font-bold py-2.5 rounded hover:bg-sky-300 shadow-md">
                        更新する
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div id="app-toast"
        class="fixed bottom-24 left-1/2 -translate-x-1/2 bg-gray-800 text-white px-4 py-2 rounded-full text-xs font-bold border border-gray-600 shadow-2xl z-[300] hidden transition-opacity duration-300 opacity-0">
    </div>

    <script>
        // --- 1. Variables & Base Data ---
        const APP_VERSION = "v3.7"; // ★変更を加えるたびにここを書き換える
        const ALL_SUBJECTS_ID = 'all';
        const SUBJECT_FIXED_COLORS = { chemistry: 'text-app-accent', math: 'text-green-400', physics: 'text-purple-400' };
        const COLOR_PALETTE = ['text-sky-400', 'text-emerald-400', 'text-violet-400', 'text-amber-400', 'text-rose-400', 'text-fuchsia-400', 'text-cyan-400', 'text-lime-400', 'text-indigo-400', 'text-pink-400', 'text-yellow-400', 'text-teal-400', 'text-blue-500', 'text-green-500', 'text-purple-500', 'text-orange-500', 'text-red-500', 'text-blue-300', 'text-green-300', 'text-purple-300', 'text-orange-300', 'text-rose-300', 'text-emerald-300', 'text-sky-300'];
        const TICKER_COLOR_CLASSES = [
            'text-red-400', 'text-orange-400', 'text-amber-400', 'text-yellow-400',
            'text-lime-400', 'text-green-400', 'text-emerald-400', 'text-teal-400',
            'text-cyan-400', 'text-sky-400', 'text-blue-400', 'text-indigo-400',
            'text-violet-400', 'text-purple-400', 'text-fuchsia-400', 'text-pink-400',
            'text-rose-400', 'text-gray-400'
        ];

        const defaultSubjects = {
            chemistry: { id: 'chemistry', type: 'study', name: '化学', examDate: null, startDate: null, isActive: true, syllabus: [], history: {} }
        };

        const defaultTicker = {
            categories: [
                { id: 'tips', name: 'Tips', color: 'text-blue-400', weight: 10 },
                { id: 'quote', name: '名言', color: 'text-yellow-400', weight: 5 }
            ],
            messages: [], // 初期は空
            isPaused: false,
            isEnabled: true
        };



        let appData = getBlankData();
        let currentRecordDate = new Date();
        let currentCalendarDate = new Date();
        let selectedDateString = null;
        let editingSubjectId = null;
        let editingUnitIndex = null;

        let tickerInterval = null;
        let editingTickerCatId = null;

        // --- 2. Utils ---

        function escapeHtml(text) {
            if (text === null || text === undefined) return '';
            return String(text)
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }
        function getToday() { return new Date(); }
        function getTodayStr() { return formatDate(getToday()); }
        function formatDate(date) { const y = date.getFullYear(); const m = String(date.getMonth() + 1).padStart(2, '0'); const d = String(date.getDate()).padStart(2, '0'); return `${y}-${m}-${d}`; }
        function formatShortDate(date) { return `${date.getMonth() + 1}/${date.getDate()}`; }
        function getActiveSubjects() { return Object.values(appData.subjects).filter(s => s.isActive && s.type === 'study'); }
        function getActiveChallenges() { return Object.values(appData.subjects).filter(s => s.isActive && s.type === 'challenge'); }

        function getSubjectColor(subjId) {
            if (SUBJECT_FIXED_COLORS[subjId]) return SUBJECT_FIXED_COLORS[subjId];
            const subj = appData.subjects[subjId];
            if (!subj) return 'text-gray-400';
            if (subj.type === 'challenge') return 'text-challenge-gold';
            let hash = 0; const name = subj.name;
            for (let i = 0; i < name.length; i++) { hash = name.charCodeAt(i) + ((hash << 5) - hash); }
            const index = Math.abs(hash) % COLOR_PALETTE.length;
            return COLOR_PALETTE[index];
        }

        function showToast(msg) {
            const toast = document.getElementById('app-toast');
            if (!toast) return;
            toast.textContent = msg; toast.classList.remove('hidden');
            setTimeout(() => { toast.classList.remove('opacity-0'); toast.classList.add('opacity-100'); }, 10);
            setTimeout(() => { toast.classList.replace('opacity-100', 'opacity-0'); setTimeout(() => toast.classList.add('hidden'), 300); }, 2500);
        }

        function showAppConfirm(title, body, onOk) {
            const modal = document.getElementById('app-modal');
            document.getElementById('app-modal-title').textContent = title;
            document.getElementById('app-modal-body').textContent = body;
            const okBtn = document.getElementById('app-modal-ok');
            const cancelBtn = document.getElementById('app-modal-cancel');
            modal.classList.remove('hidden');
            const newOkBtn = okBtn.cloneNode(true); okBtn.parentNode.replaceChild(newOkBtn, okBtn);
            newOkBtn.onclick = () => { modal.classList.add('hidden'); onOk(); };
            cancelBtn.onclick = () => { modal.classList.add('hidden'); };
        }

        function copyTextToClipboard(text) {
            const textArea = document.createElement("textarea"); textArea.value = text; document.body.appendChild(textArea); textArea.select(); document.execCommand('copy'); document.body.removeChild(textArea);
        }

        // =========================================================
        // --- 3. Data Logic (Firebase Cloud Sync & Secure Auth) ---
        // =========================================================

        const firebaseConfig = {
            apiKey: "AIzaSyAkEQmBcH-oljaA1TN1abBYuoFoffCvPzY",
            authDomain: "studyapp-ae039.firebaseapp.com",
            projectId: "studyapp-ae039",
            storageBucket: "studyapp-ae039.firebasestorage.app",
            messagingSenderId: "238524267683",
            appId: "1:238524267683:web:ca0706ec5ff57e6cafd316"
        };

        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        }
        const db = firebase.firestore();

        let currentUserDocId = null;

        let googleAccessToken = null; // ★追加：Google API用トークン

        // ★修正版：連打防止機能付きのログイン関数
        // ★修正版：ログアウト後の再ログインも可能なログイン関数
        let isLoginProcessing = false;

        function performGoogleLogin() {
            // 処理中なら何もしない
            if (isLoginProcessing) return;
            isLoginProcessing = true;

            const btn = document.querySelector('button[onclick="performGoogleLogin()"]');
            if (btn) {
                btn.style.opacity = "0.5";
                btn.innerText = "接続中...";
            }

            const provider = new firebase.auth.GoogleAuthProvider();
            provider.addScope('https://www.googleapis.com/auth/tasks');
            provider.addScope('https://www.googleapis.com/auth/spreadsheets');

            firebase.auth().signInWithPopup(provider)
                .then((result) => {
                    googleAccessToken = result.credential.accessToken;
                    document.getElementById('login-error').textContent = "";

                    // ★ここが修正点：成功時もしっかりフラグとボタンを元に戻す
                    isLoginProcessing = false;
                    if (btn) {
                        btn.style.opacity = "1";
                        btn.innerHTML = `<svg class="w-5 h-5 mr-3" viewBox="0 0 24 24"><path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" fill="#4285F4"/><path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" fill="#34A853"/><path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.84z" fill="#FBBC05"/><path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="#EA4335"/></svg>Googleでログイン`;
                    }
                })
                .catch((error) => {
                    console.error(error);
                    let msg = "ログイン失敗: " + error.message;

                    if (error.code === 'auth/cancelled-popup-request') {
                        msg = "エラー: ログイン画面が既に開いているか、連打されました。もう一度お試しください。";
                    } else if (error.code === 'auth/popup-closed-by-user') {
                        msg = "ログイン画面が閉じられました。";
                    } else if (error.code === 'auth/popup-blocked') {
                        msg = "ポップアップがブロックされました。ブラウザの設定を許可してください。";
                    } else if (error.message.includes("The requested action is invalid")) {
                        msg = "設定エラー: Firebaseのコンソールで「承認済みドメイン」を確認してください。";
                    }

                    document.getElementById('login-error').textContent = msg;

                    // 失敗時も戻す
                    isLoginProcessing = false;
                    if (btn) {
                        btn.style.opacity = "1";
                        btn.innerHTML = `<svg class="w-5 h-5 mr-3" viewBox="0 0 24 24"><path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" fill="#4285F4"/><path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" fill="#34A853"/><path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.84z" fill="#FBBC05"/><path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="#EA4335"/></svg>Googleでログイン`;
                    }
                });
        }

        // ★追加：Google ToDoリストへ送信する関数
        // ★変更：Google ToDoリストへ送信する関数（親切バージョン）
        function addToGoogleTasks(title, dateStr) {
            // 合鍵がない場合、アラートを出して教える
            if (!googleAccessToken) {
                alert("【同期失敗】\nGoogle ToDoリストへの接続が切れています。\n設定メニューから一度「ログアウト」し、再度ログインしてください。");
                return;
            }

            const due = dateStr + 'T00:00:00.000Z';

            fetch('https://tasks.googleapis.com/tasks/v1/lists/@default/tasks', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${googleAccessToken}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    title: `[学習] ${title}`,
                    due: due
                })
            }).then(response => {
                if (response.ok) {
                    showToast("Google ToDoにも追加しました");
                } else {
                    console.error("Task sync failed", response);
                    alert("同期エラーが発生しました。コンソールを確認してください。");
                }
            });
        } // ★ここで区切るのが正解です！

        // ★修正版：Gemini向けの注釈追加 ＆ 再ログインフローを親切にした関数
        async function exportToGoogleSheets() {
            // トークンチェック（期限切れ対応）
            if (!googleAccessToken) {
                // × 今までの「ログアウトしてください」をやめて、その場で再接続を案内
                if (confirm("Google連携の接続が切れています。\n再接続（ログイン）しますか？")) {
                    performGoogleLogin();
                }
                return;
            }

            showToast("スプレッドシートを更新中...");

            try {
                let spreadsheetId = appData.geminiSpreadsheetId;
                let isNewSheet = false;

                // 1. シートの存在確認
                if (spreadsheetId) {
                    const checkRes = await fetch(`https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}`, {
                        method: 'GET',
                        headers: { 'Authorization': `Bearer ${googleAccessToken}` }
                    });
                    if (!checkRes.ok) {
                        console.log("前回のファイルが見つかりません。新規作成します。");
                        spreadsheetId = null; // リセット
                    }
                }

                // 2. 新規作成 (IDがない場合)
                if (!spreadsheetId) {
                    showToast("新しいシートを作成中...");
                    const createRes = await fetch('https://sheets.googleapis.com/v4/spreadsheets', {
                        method: 'POST',
                        headers: { 'Authorization': `Bearer ${googleAccessToken}`, 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            properties: { title: `学習管理データ (Gemini連携用)` },
                            sheets: [
                                { properties: { title: 'サマリー(進捗)', gridProperties: { frozenRowCount: 1 } } },
                                { properties: { title: '全単元リスト', gridProperties: { frozenRowCount: 1 } } },
                                { properties: { title: '日次推移(Daily)', gridProperties: { frozenRowCount: 1 } } },
                                { properties: { title: 'チャレンジ記録', gridProperties: { frozenRowCount: 1 } } },
                                { properties: { title: '生活リズム', gridProperties: { frozenRowCount: 1 } } },
                                { properties: { title: '勉強時間', gridProperties: { frozenRowCount: 1 } } } // ★追加
                            ]
                        })
                    });

                    if (!createRes.ok) throw new Error("シート作成に失敗しました");

                    const sheetData = await createRes.json();
                    spreadsheetId = sheetData.spreadsheetId;
                    appData.geminiSpreadsheetId = spreadsheetId;
                    saveData();
                    isNewSheet = true;
                }

                // 3. データの準備
                const today = getToday();

                // (A) サマリー
                const summaryRows = [['科目名', '進捗率(%)', '完了数', '全単元数', '開始日', '経過日数', '平均ペース(単元/日)', '完了予測日', '状態']];
                Object.values(appData.subjects).forEach(s => {
                    if (s.type === 'study') {
                        const total = s.syllabus ? s.syllabus.length : 0;
                        const done = s.syllabus ? s.syllabus.filter(u => u.status === 'completed').length : 0;
                        const progress = total > 0 ? Math.round((done / total) * 100) : 0;
                        const startDate = s.startDate ? new Date(s.startDate) : new Date();
                        const elapsed = Math.max(1, Math.floor((today - startDate) / 86400000));
                        const pace = (done / elapsed).toFixed(2);
                        let estDate = '-';
                        if (done > 0 && total > done) {
                            const remaining = total - done;
                            const daysNeeded = Math.ceil(remaining / (done / elapsed));
                            const d = new Date(today);
                            d.setDate(d.getDate() + daysNeeded);
                            estDate = formatDate(d);
                        } else if (total > 0 && total === done) estDate = '完了済';

                        summaryRows.push([
                            s.name, progress, done, total,
                            s.startDate || '-', elapsed, pace, estDate,
                            s.isActive ? '学習中' : '停止中'
                        ]);
                    }
                });

                // (B) 全単元リスト
                const detailRows = [['科目', 'カテゴリ', '単元名', '状態', '完了日', '苦手フラグ', '周回数', 'メモ']];
                Object.values(appData.subjects).forEach(s => {
                    if (s.type === 'study' && s.syllabus) {
                        s.syllabus.forEach(u => {
                            detailRows.push([
                                s.name, u.category, u.title,
                                u.status === 'completed' ? '完了' : '未完了',
                                u.completedDate === 'initial' ? '既遂' : (u.completedDate || ''),
                                u.isWeak ? '苦手' : '',
                                u.lapCount || 0,
                                u.memo || ''
                            ]);
                        });
                    }
                });

                // (C) 日次推移 (Daily)
                const historyRows = [['日付', '科目名', '進捗率(%)']];
                Object.values(appData.subjects).forEach(s => {
                    if (s.type === 'study' && s.isActive) {
                        let start = s.startDate ? new Date(s.startDate) : null;
                        if (!start && s.history) {
                            const dates = Object.keys(s.history).sort();
                            if (dates.length > 0) start = new Date(dates[0]);
                        }
                        if (!start) start = new Date(today);

                        let cursor = new Date(start);
                        let lastVal = 0;
                        while (cursor <= today) {
                            const dStr = formatDate(cursor);
                            if (s.history && s.history[dStr] !== undefined) lastVal = s.history[dStr];
                            historyRows.push([dStr, s.name, lastVal]);
                            cursor.setDate(cursor.getDate() + 1);
                        }
                    }
                });

                // (D) チャレンジ記録
                const challengeRows = [['日付', 'チャレンジ名', '達成', '曜日', '【備考: このシートには実施した日のみ記録されています。日付がない日は未実施です。】']];
                const weekDays = ['日', '月', '火', '水', '木', '金', '土'];
                Object.values(appData.subjects).forEach(s => {
                    if (s.type === 'challenge' && s.challengeHistory) {
                        Object.keys(s.challengeHistory).sort().forEach(date => {
                            const d = new Date(date);
                            challengeRows.push([date, s.name, 'TRUE', weekDays[d.getDay()], '']);
                        });
                    }
                });

                // (Z) ヘルパー: 分を「X時間Y分」に変換
                const formatDuration = (m) => {
                    if (m === '' || m === null || isNaN(m)) return '';
                    const hours = Math.floor(m / 60);
                    const mins = m % 60;
                    return `${hours}時間${mins}分`;
                };

                // (E) 生活リズム
                const sleepLogRows = [['日付', '起床時間', '就寝時間', '睡眠時間']];
                if (appData.sleepLog) {
                    const sortedDates = Object.keys(appData.sleepLog).sort();
                    sortedDates.forEach(date => {
                        const log = appData.sleepLog[date];
                        let duration = '';
                        // 当日の起床時間
                        const wake = timeToMinutes(log.wake);

                        // 前日の就寝時間を取得
                        const dObj = new Date(date);
                        dObj.setDate(dObj.getDate() - 1);
                        const prevDate = formatDate(dObj);
                        const prevLog = appData.sleepLog[prevDate];

                        if (wake !== null && prevLog && prevLog.bed) {
                            const prevBed = timeToMinutes(prevLog.bed, true);
                            if (prevBed !== null) {
                                // 前日就寝〜当日起床
                                duration = (wake + 1440) - prevBed;
                            }
                        }
                        sleepLogRows.push([date, log.wake || '', log.bed || '', formatDuration(duration)]);
                    });
                }

                // (F) 勉強時間
                const studyLogRows = [['日付', '勉強時間']];
                if (appData.studyLog) {
                    Object.keys(appData.studyLog).sort().forEach(date => {
                        const log = appData.studyLog[date];
                        studyLogRows.push([date, formatDuration(log.time)]);
                    });
                }

                // 4. 完全クリア & 書き込み
                if (!isNewSheet) {
                    await fetch(`https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}/values:batchClear`, {
                        method: 'POST',
                        headers: { 'Authorization': `Bearer ${googleAccessToken}`, 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            ranges: [
                                "'サマリー(進捗)'!A:Z",
                                "'全単元リスト'!A:Z",
                                "'日次推移(Daily)'!A:Z",
                                "'チャレンジ記録'!A:Z",
                                "'生活リズム'!A:Z",
                                "'勉強時間'!A:Z"
                            ]
                        })
                    });
                }

                const dataBody = [];
                dataBody.push({ range: `'サマリー(進捗)'!A1`, values: summaryRows });
                dataBody.push({ range: `'全単元リスト'!A1`, values: detailRows });
                dataBody.push({ range: `'日次推移(Daily)'!A1`, values: historyRows });
                dataBody.push({ range: `'チャレンジ記録'!A1`, values: challengeRows });
                dataBody.push({ range: `'生活リズム'!A1`, values: sleepLogRows });
                dataBody.push({ range: `'勉強時間'!A1`, values: studyLogRows });

                if (dataBody.length > 0) {
                    await fetch(`https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}/values:batchUpdate`, {
                        method: 'POST',
                        headers: { 'Authorization': `Bearer ${googleAccessToken}`, 'Content-Type': 'application/json' },
                        body: JSON.stringify({ valueInputOption: 'USER_ENTERED', data: dataBody })
                    });
                }

                showToast("更新完了！シートを開きます");
                window.open(`https://docs.google.com/spreadsheets/d/${spreadsheetId}`, '_blank');

            } catch (e) {
                console.error(e);
                // エラー時の再ログイン誘導も親切にする
                if (e.message.includes("401") || e.message.includes("auth")) {
                    if (confirm("認証の有効期限が切れました。\n再ログインしてやり直しますか？")) {
                        performGoogleLogin();
                    }
                } else {
                    alert("エクスポートに失敗しました。\n詳細: " + e.message);
                }
            }
        }

        function saveData() {
            if (currentUserDocId) {
                // ログイン中はFirestore(クラウド)に保存
                db.collection("study_apps").doc(currentUserDocId).set(JSON.parse(JSON.stringify(appData)))
                    .then(() => console.log("Data saved to cloud"))
                    .catch((error) => console.error("Save error:", error));
            } else {
                // 未ログイン時はローカル保存（念のため）
                localStorage.setItem('studyApp_v2_data', JSON.stringify(appData));
            }
        }

        function startListening() {
            if (!currentUserDocId) return;
            db.collection("study_apps").doc(currentUserDocId).onSnapshot((doc) => {
                if (doc.exists) {
                    console.log("Data received from cloud");
                    const cloudData = doc.data();
                    appData = migrateData(cloudData);
                    appData.debugDate = null;
                    initTicker(); // データロード後にティッカー開始
                    recordHistory();
                    updateUI();
                } else {
                    console.log("No data found, initializing...");
                    saveData();
                }
            }, (error) => {
                console.error("Sync error:", error);
                if (error.code === 'permission-denied') {
                    alert("データの読み込み権限がありません。");
                }
            });
        }

        function migrateData(data) {
            if (!data.subjects) return data;
            Object.values(data.subjects).forEach(subj => {
                if (subj.isActive === undefined) subj.isActive = true;
                if (!subj.type) subj.type = 'study';
                if (!subj.history) subj.history = {};
                if (subj.type === 'challenge' && !subj.challengeHistory) subj.challengeHistory = {};
            });
            if (!data.ticker) data.ticker = JSON.parse(JSON.stringify(defaultTicker));
            if (data.ticker.isEnabled === undefined) data.ticker.isEnabled = true;
            if (!data.sleepLog) data.sleepLog = {};
            return data;
        }

        function recordHistory() {
            const dateStr = getTodayStr();
            Object.values(appData.subjects).forEach(subj => {
                if (subj.type === 'study') {
                    if (!subj.history) subj.history = {};
                    const total = subj.syllabus ? subj.syllabus.length : 0;
                    if (total === 0) return;
                    const completed = subj.syllabus.filter(i => i.status === 'completed').length;
                    subj.history[dateStr] = Math.round((completed / total) * 100);
                }
            });
            saveData();
        }

        function getProgressAt(s, d) {
            if (!s || !s.history) return 0;
            if (s.history[d] !== undefined) return s.history[d];
            const sorted = Object.keys(s.history).sort();
            let last = null;
            for (const x of sorted) { if (x <= d) last = x; else break; }
            return last ? s.history[last] : 0;
        }

        function calculateLeastSquares(points) {
            const n = points.length; if (n < 2) return null;
            let sx = 0, sy = 0, sxy = 0, sx2 = 0;
            for (const p of points) { sx += p.x; sy += p.y; sxy += p.x * p.y; sx2 += p.x * p.x; }
            const slope = (n * sxy - sx * sy) / (n * sx2 - sx * sx);
            const intercept = (sy - slope * sx) / n;
            return { slope, intercept };
        }

        function calculateChallengeStats(subj) {
            const start = subj.startDate ? new Date(subj.startDate) : getToday();
            const today = getToday();
            const totalDays = Math.max(1, Math.floor((today - start) / 86400000) + 1);
            let currentStreak = 0; let streakBroken = false;
            for (let i = 0; i < totalDays; i++) {
                const d = new Date(today); d.setDate(d.getDate() - i); const dStr = formatDate(d);
                if (subj.challengeHistory[dStr]) { if (!streakBroken) currentStreak++; } else { if (i > 0) streakBroken = true; }
            }
            let doneDays = 0; for (let k in subj.challengeHistory) { if (subj.challengeHistory[k] && new Date(k) >= start && new Date(k) <= today) doneDays++; }
            return { totalDays, doneDays, currentStreak, percentage: Math.round((doneDays / totalDays) * 100) };
        }

        function getStreakMessage(streak) {
            if (streak === 0) return "今日からスタート！";
            if (streak < 3) return "いい調子！";
            if (streak < 7) return "三日坊主脱出！";
            if (streak < 14) return "習慣化の兆し！";
            if (streak < 30) return "継続の達人！";
            return "レジェンド級！";
        }

        // =========================================================
        // --- Ticker Logic ---
        // =========================================================
        function initTicker() {
            updateTickerVisibility();
            if (tickerInterval) clearInterval(tickerInterval);
            tickerInterval = null;

            if (!appData.ticker.isEnabled) return;

            const wrappers = document.querySelectorAll('.ticker-wrapper');

            if (appData.ticker.isPaused) {
                wrappers.forEach(wrapper => {
                    wrapper.innerHTML = '<div class="ticker-item text-xs text-gray-500">Loading...</div>';
                });
            } else {
                renderTicker(); // First render
                tickerInterval = setInterval(updateTicker, 10000);
            }
            updateTickerPauseBtn();
        }

        function updateTickerVisibility() {
            const box = document.getElementById('header-ticker-box');
            if (!box) return;
            if (appData.ticker.isEnabled) {
                box.classList.add('sm:block');
            } else {
                box.classList.remove('sm:block');
            }
            if (!box.classList.contains('hidden')) box.classList.add('hidden');
        }

        function updateTicker() {
            if (appData.ticker.isPaused) return;

            const wrappers = document.querySelectorAll('.ticker-wrapper');
            if (wrappers.length === 0) return;

            const nextMsg = getWeightedRandomMessage();

            wrappers.forEach(wrapper => {
                if (!nextMsg) {
                    wrapper.innerHTML = '<div class="ticker-item text-xs text-gray-500">メッセージがありません</div>';
                    return;
                }

                // 既存の要素をすべて取得
                const oldItems = Array.from(wrapper.children);

                // 次の要素を作成
                const nextEl = document.createElement('div');
                nextEl.className = 'ticker-item ticker-slide-enter';

                const cat = appData.ticker.categories.find(c => c.id === nextMsg.categoryId);
                const colorClass = cat ? cat.color : 'text-gray-400';
                const catName = cat ? cat.name : '';

                nextEl.innerHTML = `
                    <span class="ticker-category-badge ${colorClass}">${escapeHtml(catName)}</span>
                    <span class="text-xs text-gray-200 truncate">${escapeHtml(nextMsg.text)}</span>
                `;

                wrapper.appendChild(nextEl);

                // 古い要素を退場させる
                oldItems.forEach(el => {
                    el.classList.remove('ticker-slide-enter');
                    el.classList.add('ticker-slide-exit');
                    setTimeout(() => { if (el.parentNode) el.remove(); }, 480);
                });
            });
        }

        function renderTicker() {
            // 強制的に更新をかける（初期表示用）
            updateTicker();
        }

        function forceNextTicker() {
            // 無効化中や一時停止中はクリックしても進まないようにする
            if (!appData.ticker.isEnabled || appData.ticker.isPaused) return;

            updateTicker();
            clearInterval(tickerInterval);
            tickerInterval = setInterval(updateTicker, 10000);
        }

        function toggleTickerEnabled() {
            const isEnabled = document.getElementById('ticker-enabled-toggle').checked;
            appData.ticker.isEnabled = isEnabled;
            saveData();
            initTicker();
        }

        function toggleTickerPause(e) {
            if (e) e.stopPropagation();
            appData.ticker.isPaused = !appData.ticker.isPaused;
            saveData();
            initTicker();
        }

        function updateTickerPauseBtn() {
            const btns = document.querySelectorAll('.ticker-pause-btn');
            btns.forEach(btn => {
                btn.innerHTML = appData.ticker.isPaused ? '<i class="fas fa-play text-app-accent"></i>' : '<i class="fas fa-pause"></i>';
                btn.style.opacity = appData.ticker.isPaused ? "1" : ""; // 停止中は常に表示
            });
        }

        function getWeightedRandomMessage() {
            const ticker = appData.ticker;
            if (!ticker || !ticker.messages || ticker.messages.length === 0) return null;

            // カテゴリごとの重みマップ作成
            const defaultWeight = 1;
            const weightedMessages = ticker.messages.map(msg => {
                const cat = ticker.categories.find(c => c.id === msg.categoryId);
                const weight = cat ? (parseInt(cat.weight) || 1) : defaultWeight;
                return { msg, weight };
            });

            const sum = weightedMessages.reduce((acc, item) => acc + item.weight, 0);
            let r = Math.random() * sum;

            for (const item of weightedMessages) {
                if (r < item.weight) return item.msg;
                r -= item.weight;
            }
            return weightedMessages[0].msg;
        }


        function addNewTickerCategory() {
            const id = 'cat_' + Date.now();
            const newCat = { id: id, name: '新規カテゴリ', color: 'text-gray-400', weight: 10 };
            appData.ticker.categories.push(newCat);
            saveData();
            renderTickerSettings();
            openTickerCategoryEditor(id);
        }

        function deleteTickerCategory(catId) {
            const category = appData.ticker.categories.find(c => c.id === catId);
            if (!category) return;
            showAppConfirm("カテゴリの削除", `カテゴリ「${category.name}」と、紐づくメッセージを全て削除しますか？`, () => {
                appData.ticker.categories = appData.ticker.categories.filter(c => c.id !== catId);
                appData.ticker.messages = appData.ticker.messages.filter(m => m.categoryId !== catId);
                saveData();
                renderTickerSettings();
                initTicker();
                showToast("削除しました");
            });
        }

        function openBulkWeightEditor() {
            const list = document.getElementById('bulk-weight-list');
            list.innerHTML = '';
            appData.ticker.categories.forEach(cat => {
                const div = document.createElement('div');
                div.innerHTML = `
                    <label class="text-[10px] text-gray-400 block mb-1">${escapeHtml(cat.name)}: <span class="font-bold text-white" id="bulk-weight-value-${cat.id}">${cat.weight}</span></label>
                    <input type="range" id="bulk-weight-slider-${cat.id}" min="1" max="20" value="${cat.weight}" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                `;
                list.appendChild(div);
                const slider = document.getElementById(`bulk-weight-slider-${cat.id}`);
                const valueLabel = document.getElementById(`bulk-weight-value-${cat.id}`);
                slider.oninput = () => {
                    valueLabel.textContent = slider.value;
                };
            });
            document.getElementById('ticker-bulk-weight-editor').classList.remove('hidden');
        }

        function closeBulkWeightEditor() {
            document.getElementById('ticker-bulk-weight-editor').classList.add('hidden');
        }

        function saveBulkWeights() {
            appData.ticker.categories.forEach(cat => {
                const slider = document.getElementById(`bulk-weight-slider-${cat.id}`);
                if (slider) {
                    cat.weight = parseInt(slider.value);
                }
            });
            saveData();
            renderTickerSettings();
            closeBulkWeightEditor();
            showToast("重みを一括更新しました");
        }


        // ▼▼▼ 修正箇所ここから ▼▼▼

        function openTickerCategoryEditor(catId) {
            editingTickerCatId = catId;
            const cat = appData.ticker.categories.find(c => c.id === catId);
            if (!cat) return;

            document.getElementById('edit-ticker-cat-name').value = cat.name;

            const colorValueInput = document.getElementById('edit-ticker-cat-color-value');
            colorValueInput.value = cat.color;

            const palette = document.getElementById('edit-ticker-cat-color-palette');
            palette.innerHTML = '';
            TICKER_COLOR_CLASSES.forEach(colorClass => {
                const swatch = document.createElement('div');
                const bgColor = colorClass.replace('text-', 'bg-');
                swatch.className = `w-full h-8 rounded cursor-pointer border-2 ${bgColor} transition-all`;
                swatch.dataset.colorClass = colorClass;

                if (cat.color === colorClass) {
                    swatch.classList.add('border-white', 'ring-2', 'ring-offset-2', 'ring-offset-app-panel', 'ring-white');
                } else {
                    swatch.classList.add('border-transparent');
                }

                swatch.onclick = () => {
                    colorValueInput.value = colorClass;
                    Array.from(palette.children).forEach(child => {
                        child.classList.remove('border-white', 'ring-2', 'ring-offset-2', 'ring-offset-app-panel', 'ring-white');
                        child.classList.add('border-transparent');
                    });
                    swatch.classList.remove('border-transparent');
                    swatch.classList.add('border-white', 'ring-2', 'ring-offset-2', 'ring-offset-app-panel', 'ring-white');
                };
                palette.appendChild(swatch);
            });

            const weightSlider = document.getElementById('edit-ticker-cat-weight');
            const weightValue = document.getElementById('edit-ticker-cat-weight-value');
            weightSlider.value = cat.weight;
            weightValue.textContent = cat.weight;
            weightSlider.oninput = () => {
                weightValue.textContent = weightSlider.value;
            };

            renderEditorTickerMessages();
            document.getElementById('ticker-category-editor').classList.remove('hidden');
        }

        function closeTickerCategoryEditor() {
            document.getElementById('ticker-category-editor').classList.add('hidden');
            editingTickerCatId = null;
        }

        function saveTickerCategoryInfo() {
            const cat = appData.ticker.categories.find(c => c.id === editingTickerCatId);
            if (cat) {
                cat.name = document.getElementById('edit-ticker-cat-name').value.trim() || '名称未設定';
                cat.color = document.getElementById('edit-ticker-cat-color-value').value;
                cat.weight = parseInt(document.getElementById('edit-ticker-cat-weight').value) || 10;
                saveData();
                renderTickerSettings();
                initTicker();
                showToast("カテゴリ設定を更新しました");
                closeTickerCategoryEditor();
            }
        }

        function renderEditorTickerMessages() {
            const list = document.getElementById('editor-ticker-msg-list');
            list.innerHTML = '';

            const targetMsgs = appData.ticker.messages
                .map((msg, index) => ({ msg, index }))
                .filter(item => item.msg.categoryId === editingTickerCatId);

            if (targetMsgs.length === 0) {
                list.innerHTML = '<div class="text-xs text-gray-500 text-center py-4">メッセージがありません</div>';
            } else {
                targetMsgs.forEach(item => {
                    const div = document.createElement('div');
                    div.className = "flex justify-between items-center border-b border-gray-800 py-2 last:border-0 group";
                    div.innerHTML = `
                        <span class="text-xs text-gray-300 flex-1 mr-2 break-all">${escapeHtml(item.msg.text)}</span>
                        <button onclick="deleteTickerMessageInEditor(${item.index})" class="text-gray-500 hover:text-red-400 px-2"><i class="fas fa-trash"></i></button>
                    `;
                    list.appendChild(div);
                });
            }
        }

        function addTickerMessageInEditor() {
            const input = document.getElementById('new-ticker-msg-input');
            const text = input.value.trim();
            if (!text) return;

            appData.ticker.messages.push({ categoryId: editingTickerCatId, text: text });
            saveData();
            input.value = '';
            renderEditorTickerMessages();
            renderTickerSettings(); // 件数更新のため
            initTicker();
        }

        function deleteTickerMessageInEditor(index) {
            const message = appData.ticker.messages[index];
            if (!message) return;
            showAppConfirm("メッセージの削除", `メッセージ「${message.text}」を削除しますか？`, () => {
                appData.ticker.messages.splice(index, 1);
                saveData();
                renderEditorTickerMessages();
                renderTickerSettings();
                showToast("メッセージを削除しました");
            });
        }

        // ★追加: 未定義だった関数を実装
        function renderTickerSettings() {
            const list = document.getElementById('ticker-category-list');
            if (!list) return;
            list.innerHTML = '';

            const tickerEnabledToggle = document.getElementById('ticker-enabled-toggle');
            if (tickerEnabledToggle) {
                tickerEnabledToggle.checked = !!appData.ticker.isEnabled;
            }

            const categories = appData.ticker.categories || [];

            if (categories.length === 0) {
                list.innerHTML = '<div class="text-xs text-gray-500 text-center py-2">カテゴリがありません</div>';
            } else {
                categories.forEach(cat => {
                    const div = document.createElement('div');
                    div.className = "flex justify-between items-center bg-gray-800 p-2 rounded border border-gray-700 mb-2";
                    div.innerHTML = `
                        <div class="flex items-center gap-2 overflow-hidden">
                            <span class="text-[10px] px-1.5 py-0.5 rounded border border-current font-bold ${cat.color}">${escapeHtml(cat.name)}</span>
                            <span class="text-[9px] text-gray-500 shrink-0">重み:${cat.weight}</span>
                        </div>
                        <div class="flex gap-1 shrink-0">
                            <button onclick="openTickerCategoryEditor('${cat.id}')" class="text-gray-400 hover:text-white px-2 py-1"><i class="fas fa-pen"></i></button>
                            <button onclick="deleteTickerCategory('${cat.id}')" class="text-gray-400 hover:text-red-400 px-2 py-1"><i class="fas fa-trash"></i></button>
                        </div>
                    `;
                    list.appendChild(div);
                });
            }

            // 全メッセージ数の更新
            const msgCountEl = document.getElementById('ticker-msg-count');
            if (msgCountEl) {
                msgCountEl.textContent = (appData.ticker.messages || []).length;
            }
        }

        // ▲▲▲ 修正箇所ここまで ▲▲▲


        function copyTickerPrompt() {
            const text = `学習管理アプリのニュースティッカー用データをJSON形式で作成してください。\n\n形式:\n{\n  "categories": [\n    {"id": "tips", "name": "学習のコツ", "color": "text-blue-400", "weight": 10},\n    {"id": "quote", "name": "偉人の名言", "color": "text-yellow-400", "weight": 5}\n  ],\n  "messages": [\n    {"categoryId": "tips", "text": "ポモドーロテクニックを使ってみよう"},\n    {"categoryId": "quote", "text": "天才とは1%のひらめきと99%の努力である"}\n  ]\n}\n\n条件:\n- 学習のモチベーションが上がる内容\n- 短く簡潔に(30文字以内)\n- 合計20件程度`;
            copyTextToClipboard(text);
            showToast("プロンプトをコピーしました");
        }


        // --- 4. Render Logic (Renders UI parts) ---
        function updateHeaderDate() {
            const d = getToday(); const days = ['日', '月', '火', '水', '木', '金', '土'];
            document.getElementById('header-date-display').textContent = `${d.getMonth() + 1}/${d.getDate()}(${days[d.getDay()]})`;

            // ★追加：バージョン情報を設定画面に反映
            const versionEl = document.getElementById('app-version-display');
            if (versionEl) versionEl.textContent = APP_VERSION;
        }

        function updateExamDaysDisplay() {
            const today = getToday();
            if (appData.currentSubjectId === ALL_SUBJECTS_ID) {
                let minDiff = Infinity; let found = false;
                getActiveSubjects().forEach(s => { if (s.examDate) { const d = Math.ceil((new Date(s.examDate) - today) / 86400000); if (d >= 0 && d < minDiff) { minDiff = d; found = true; } } });
                const text = found ? `目標まで ${minDiff} 日` : '目標日未設定';
                document.getElementById('exam-days-left').textContent = text; document.getElementById('exam-days-left-mobile').textContent = text;
            } else {
                const subj = appData.subjects[appData.currentSubjectId];
                if (!subj || !subj.examDate) {
                    const text = "目標日未設定";
                    document.getElementById('exam-days-left').textContent = text; document.getElementById('exam-days-left-mobile').textContent = text;
                } else {
                    const diff = Math.ceil((new Date(subj.examDate) - today) / 86400000);
                    const text = diff >= 0 ? `目標まで ${diff} 日` : `目標から ${Math.abs(diff)} 日経過`;
                    document.getElementById('exam-days-left').textContent = text; document.getElementById('exam-days-left-mobile').textContent = text;
                }
            }
        }

        function refreshSubjectSelectUI() {
            const sel = document.getElementById('subject-select'); sel.innerHTML = '';
            const allOpt = document.createElement('option'); allOpt.value = ALL_SUBJECTS_ID; allOpt.textContent = '総合 (学習科目)'; sel.appendChild(allOpt);
            const studyGroup = document.createElement('optgroup'); studyGroup.label = "学習中";
            const challengeGroup = document.createElement('optgroup'); challengeGroup.label = "継続チャレンジ";
            const inactiveGroup = document.createElement('optgroup'); inactiveGroup.label = "未学習";
            Object.values(appData.subjects).forEach(subj => {
                const opt = document.createElement('option'); opt.value = subj.id; opt.textContent = subj.name;
                if (!subj.isActive) inactiveGroup.appendChild(opt);
                else if (subj.type === 'challenge') challengeGroup.appendChild(opt);
                else studyGroup.appendChild(opt);
            });
            if (studyGroup.children.length) sel.appendChild(studyGroup);
            if (challengeGroup.children.length) sel.appendChild(challengeGroup);
            if (inactiveGroup.children.length) sel.appendChild(inactiveGroup);
            if (appData.currentSubjectId !== ALL_SUBJECTS_ID && !appData.subjects[appData.currentSubjectId]) appData.currentSubjectId = ALL_SUBJECTS_ID;
            sel.value = appData.currentSubjectId;
            sel.onchange = (e) => { appData.currentSubjectId = e.target.value; saveData(); updateUI(); };
        }

        function getCurrentSyllabus() {
            if (appData.currentSubjectId === ALL_SUBJECTS_ID) return getActiveSubjects().flatMap(subj => (subj.syllabus || []).map(item => ({ ...item, _subjectId: subj.id, _subjectName: subj.name })));
            return appData.subjects[appData.currentSubjectId]?.syllabus || [];
        }
        // ★修正版：縦長化、白線区切り、単元名中央揃え、文字隠れ防止
        // ★修正版：カテゴリ名の文字数制限を撤廃した単元マップ描画関数
        function renderSlitBar() {
            const labelContainer = document.getElementById('category-labels-container');
            const slitWrapper = document.getElementById('slit-bar-wrapper');
            labelContainer.innerHTML = '';
            slitWrapper.innerHTML = '';

            const syllabus = getCurrentSyllabus();
            if (syllabus.length === 0) return;

            // カテゴリラベル生成
            const groups = [];
            let currentLabel = null;
            syllabus.forEach(item => {
                const labelKey = appData.currentSubjectId === ALL_SUBJECTS_ID ? item._subjectName : item.category;
                if (currentLabel !== labelKey) { groups.push({ label: labelKey, count: 1 }); currentLabel = labelKey; }
                else groups[groups.length - 1].count++;
            });
            groups.forEach(group => {
                const div = document.createElement('div');
                div.className = 'category-label-top';
                div.style.width = `${(group.count / syllabus.length) * 100}%`;

                // ★修正：4文字制限(substring)を削除し、そのまま表示
                div.textContent = group.label || '';

                // 念のためツールチップ（マウスホバーで全文表示）も追加
                div.title = group.label || '';

                labelContainer.appendChild(div);
            });

            // スリット生成
            syllabus.forEach(item => {
                const slit = document.createElement('div');
                let slitClass = `slit-item ${item.status}`;
                if (item.status === 'completed' && item.isWeak) slitClass += ' weak';
                else if (item.status === 'pending' && item.isWeak) slitClass += ' weak-pending';

                slit.className = slitClass;
                slit.style.flex = "1 1 0%";
                slit.style.display = "flex";
                slit.style.flexDirection = "column";

                // --- 1. 単元名エリア (上部・可変・中央揃え) ---
                const textArea = document.createElement('div');
                textArea.style.flex = '1 1 auto';
                textArea.style.display = 'flex';
                textArea.style.flexDirection = 'column';
                textArea.style.justifyContent = 'center';
                textArea.style.alignItems = 'center';
                textArea.style.minHeight = '0';
                textArea.style.padding = '4px 0';

                const text = document.createElement('span');
                text.className = 'slit-text';
                text.textContent = item.title;
                text.style.whiteSpace = 'nowrap';

                // フォントサイズ計算ロジック
                const len = item.title.length;
                const availableHeight = 115;
                const defaultFontSize = 9;

                if (len * defaultFontSize > availableHeight) {
                    const newSize = Math.max(4, Math.floor(availableHeight / len));
                    text.style.fontSize = `${newSize}px`;
                    text.style.letterSpacing = '0px';
                } else {
                    text.style.fontSize = `${defaultFontSize}px`;
                    text.style.letterSpacing = '1px';
                }
                textArea.appendChild(text);

                // --- 2. 区切り線 (白線) ---
                const separator = document.createElement('div');
                separator.style.flex = '0 0 1px';
                separator.style.height = '1px';

                // ★修正：ライトモードかつ未完了(白背景)の場合は黒系の線にする
                const isLight = document.documentElement.classList.contains('light-mode');
                const isDarkBg = item.status === 'completed' || item.status === 'weak-pending';
                separator.style.backgroundColor = (isLight && !isDarkBg) ? 'rgba(0, 0, 0, 0.1)' : 'rgba(255, 255, 255, 0.25)';
                separator.style.width = '100%';

                // --- 3. 下部固定エリア (苦手 + 回数) ---
                const bottomArea = document.createElement('div');
                bottomArea.style.flex = '0 0 auto';
                bottomArea.style.display = 'flex';
                bottomArea.style.flexDirection = 'column';
                bottomArea.style.alignItems = 'center';
                bottomArea.style.padding = '2px 0';

                // 3-1. 苦手ボタン
                const weakBtn = document.createElement('div');
                weakBtn.className = 'slit-weak-btn';
                weakBtn.style.flex = '0 0 12px';
                weakBtn.style.height = '12px';
                weakBtn.style.fontSize = '9px';
                weakBtn.style.display = 'flex';
                weakBtn.style.alignItems = 'center';
                weakBtn.style.justifyContent = 'center';
                if (item.isWeak) weakBtn.classList.add('active');
                weakBtn.innerHTML = '<i class="fas fa-exclamation-triangle"></i>';
                weakBtn.onclick = (e) => toggleUnitWeakGlobal(item._subjectId || appData.currentSubjectId, item.id, e);

                // 3-2. 周回数表示
                const lapDiv = document.createElement('div');
                lapDiv.style.flex = '0 0 10px';
                lapDiv.style.height = '10px';
                lapDiv.style.fontSize = '9px';
                lapDiv.style.lineHeight = '10px';
                lapDiv.className = 'font-mono text-center w-full';
                const count = item.lapCount || 0;
                lapDiv.textContent = count;
                if (item.status === 'completed') {
                    lapDiv.style.color = 'rgba(0,0,0,0.7)';
                    if (count >= 2) lapDiv.style.fontWeight = 'bold';
                } else {
                    // ★修正：ライトモードなら黒文字、ダークモードなら白文字
                    lapDiv.style.color = (isLight && item.status !== 'weak-pending') ? 'rgba(0,0,0,0.4)' : 'rgba(255,255,255,0.4)';
                }

                bottomArea.appendChild(weakBtn);
                bottomArea.appendChild(lapDiv);

                slit.appendChild(textArea);
                slit.appendChild(separator);
                slit.appendChild(bottomArea);

                slitWrapper.appendChild(slit);
            });
        }


        function renderMonthHeatmap(subj) {
            const container = document.getElementById('slit-bar-wrapper'); container.innerHTML = '';
            const labels = document.getElementById('category-labels-container'); labels.innerHTML = '';
            const start = subj.startDate ? new Date(subj.startDate) : getToday();
            const end = subj.examDate ? new Date(subj.examDate) : new Date(start.getFullYear(), start.getMonth() + 5, 1);
            let cursor = new Date(start.getFullYear(), start.getMonth(), 1);
            while (cursor <= end || cursor.getMonth() === end.getMonth()) {
                const year = cursor.getFullYear(); const month = cursor.getMonth();
                const daysInMonth = new Date(year, month + 1, 0).getDate();
                let doneCount = 0;
                for (let d = 1; d <= daysInMonth; d++) { if (subj.challengeHistory[formatDate(new Date(year, month, d))]) doneCount++; }
                const percent = Math.round((doneCount / daysInMonth) * 100);
                const lDiv = document.createElement('div'); lDiv.className = 'category-label-top'; lDiv.style.flex = "1"; lDiv.textContent = `${month + 1}月`; labels.appendChild(lDiv);
                const bDiv = document.createElement('div'); bDiv.className = 'month-heat-item';
                bDiv.innerHTML = `<div class="month-heat-fill" style="height: ${percent}%; background-color: rgba(251, 191, 36, ${Math.max(0.2, percent / 100)});"></div><span class="month-heat-label">${percent}%</span>`;
                container.appendChild(bDiv);
                cursor.setMonth(cursor.getMonth() + 1);
                if (cursor > end && cursor.getMonth() !== end.getMonth()) break;
            }
        }
        // ★追加：記録画面のリストを描画する関数 
        function renderRecordLists() {
            const dateStr = formatDate(currentRecordDate);
            document.getElementById('record-date-display').textContent = dateStr;
            const isToday = dateStr === getTodayStr();
            document.getElementById('record-date-label').textContent = isToday ? "今日の予定" : "予定リスト";

            // 今日のリスト表示
            const todaysList = document.getElementById('todays-list');
            todaysList.innerHTML = '';
            const schedule = appData.schedules[dateStr] || [];
            document.getElementById('record-task-count').textContent = `${schedule.length} 単元`;

            if (schedule.length === 0) {
                todaysList.innerHTML = `<div class="text-xs text-gray-500 text-center py-8">予定はありません<br><span class="text-[9px] opacity-70">${isToday ? '管理画面から単元を追加しましょう' : ''}</span></div>`;
            } else {
                schedule.forEach(task => {
                    const subj = appData.subjects[task.subjectId];
                    if (!subj) return;
                    const unit = subj.syllabus.find(u => u.id === task.unitId);
                    if (!unit) return;
                    todaysList.appendChild(createTaskRow(unit, subj.name, true, task));
                });
            }

            // 残りの単元（キュー）表示
            const queueList = document.getElementById('queue-list');
            queueList.innerHTML = '';
            const currentSubj = appData.subjects[appData.currentSubjectId];

            if (appData.currentSubjectId !== ALL_SUBJECTS_ID && currentSubj && currentSubj.type === 'study') {
                document.getElementById('current-subject-name-record').textContent = currentSubj.name;
                const pendingUnits = currentSubj.syllabus.filter(u => u.status === 'pending');

                // 既に予定に入っているものは除外して表示するか？（今回は簡易的に全表示）
                const todaysUnitIds = schedule.map(s => s.unitId);
                const displayUnits = pendingUnits.filter(u => !todaysUnitIds.includes(u.id));

                if (displayUnits.length === 0) {
                    queueList.innerHTML = '<div class="text-xs text-gray-500 text-center py-4">未完了の単元はありません</div>';
                } else {
                    displayUnits.forEach(unit => {
                        queueList.appendChild(createTaskRow(unit, null, false, { subjectId: currentSubj.id }));
                    });
                }
            } else {
                document.getElementById('current-subject-name-record').textContent = '科目を選択';
                queueList.innerHTML = '<div class="text-xs text-gray-500 text-center py-4">科目を指定すると<br>未完了タスクが表示されます</div>';
            }

            // チャレンジボタンの表示制御
            const challengeArea = document.getElementById('challenge-action-area');
            if (currentSubj && currentSubj.type === 'challenge') {
                challengeArea.classList.remove('hidden');
                const isDone = !!currentSubj.challengeHistory[dateStr];
                const btn = document.getElementById('challenge-toggle-btn');
                const btnText = document.getElementById('challenge-btn-text');
                if (isDone) {
                    btn.className = "w-full py-4 rounded-xl font-bold text-lg shadow-lg bg-app-success text-app-dark flex items-center justify-center gap-2";
                    btnText.textContent = "達成済み！";
                    btn.onclick = () => toggleChallengeDate(currentSubj.id, dateStr, false);
                } else {
                    btn.className = "w-full py-4 rounded-xl font-bold text-lg shadow-lg bg-gray-700 text-gray-400 hover:bg-challenge-gold hover:text-app-dark transition-all flex items-center justify-center gap-2";
                    btnText.textContent = "完了にする";
                    btn.onclick = () => toggleChallengeDate(currentSubj.id, dateStr, true);
                }
            } else {
                challengeArea.classList.add('hidden');
            }
        }

        // ★修正済み：タスク行を作成する関数
        function createTaskRow(item, subjectName, isScheduled, taskData) {
            const row = document.createElement('div');
            row.className = "flex items-center justify-between p-3 border-b border-gray-700/50 hover:bg-gray-800/50 transition-colors group";

            const leftDiv = document.createElement('div');
            leftDiv.className = "flex items-center gap-3 flex-1 min-w-0";

            const checkDiv = document.createElement('div');
            const isCompleted = item.status === 'completed';
            checkDiv.className = `w-5 h-5 rounded-full flex items-center justify-center border cursor-pointer transition-all ${isCompleted ? 'bg-app-success border-app-success text-app-dark' : 'border-gray-500 text-transparent hover:border-app-accent'}`;
            checkDiv.innerHTML = '<i class="fas fa-check text-[10px]"></i>';
            checkDiv.onclick = (e) => {
                e.stopPropagation();
                toggleStatusGlobal(taskData.subjectId, item.id);
            };

            const textDiv = document.createElement('div');
            textDiv.className = "flex flex-col truncate";

            const titleDiv = document.createElement('div');
            titleDiv.className = `text-xs font-medium truncate ${isCompleted ? 'text-gray-500 line-through' : 'text-gray-200'}`;
            titleDiv.textContent = item.title;

            const subDiv = document.createElement('div');
            subDiv.className = "text-[9px] text-gray-500 truncate";
            if (subjectName) subDiv.textContent = `[${subjectName}]`;

            textDiv.appendChild(titleDiv);
            textDiv.appendChild(subDiv);
            leftDiv.appendChild(checkDiv);
            leftDiv.appendChild(textDiv);
            row.appendChild(leftDiv);

            if (isScheduled && taskData) {
                const delBtn = document.createElement('button');
                delBtn.className = "text-gray-600 hover:text-red-400 p-2 opacity-0 group-hover:opacity-100 transition-opacity";
                delBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
                delBtn.onclick = () => {
                    const dateStr = formatDate(currentRecordDate);
                    const list = appData.schedules[dateStr];
                    if (list) {
                        const idx = list.indexOf(taskData);
                        if (idx > -1) removeTaskFromDate(dateStr, idx);
                    }
                };
                row.appendChild(delBtn);
            } else if (!isScheduled) {
                const addBtn = document.createElement('button');
                addBtn.className = "text-app-accent hover:text-white p-2 opacity-0 group-hover:opacity-100 transition-opacity";
                addBtn.innerHTML = '<i class="fas fa-plus-circle"></i>';
                addBtn.onclick = () => {
                    const dateStr = formatDate(currentRecordDate);
                    if (!appData.schedules[dateStr]) appData.schedules[dateStr] = [];
                    appData.schedules[dateStr].push({ subjectId: taskData.subjectId, unitId: item.id });
                    saveData();
                    renderRecordLists();
                };
                row.appendChild(addBtn);
            }

            return row;
        }



        function toggleUnitWeakGlobal(subjectId, unitId, event) {
            if (event) event.stopPropagation();
            const subj = appData.subjects[subjectId];
            const item = subj?.syllabus.find(s => s.id === unitId);
            if (item) {
                item.isWeak = !item.isWeak;
                saveData();
                updateUI();
            }
        }

        // ★修正版：周回カウント対応のステータス切替関数
        function toggleStatusGlobal(subjectId, unitId) {
            const subj = appData.subjects[subjectId];
            const item = subj?.syllabus.find(s => s.id === unitId);
            if (!item) return;

            if (item.status === 'pending') {
                // [1] 未完了 → 完了 (1周目達成)
                item.status = 'completed';
                item.lapCount = (item.lapCount || 0) + 1;
                item.completedDate = getTodayStr();
                showToast(`完了！ (現在: ${item.lapCount}周目)`);
                // syncToGoogleTasks(item.title, true);
            } else {
                // [2] 完了済み → クリックされた場合
                // 確認ダイアログを出す
                const isLapUp = confirm(`【周回記録】\n「${item.title}」の周回数を増やしますか？\n\n[OK] = 周回数を増やす (+1)\n[キャンセル] = 未完了に戻す`);

                if (isLapUp) {
                    // 周回数を増やして、完了日を今日に更新
                    item.lapCount = (item.lapCount || 1) + 1;
                    item.completedDate = getTodayStr();
                    showToast(`周回記録を更新しました (現在: ${item.lapCount}周目)`);
                    // syncToGoogleTasks(item.title, true); // Google側にも念のため通知
                } else {
                    // 未完了に戻す (Undo)
                    item.status = 'pending';
                    item.completedDate = null;
                    if (item.lapCount > 0) item.lapCount--;
                    showToast("未完了に戻しました");
                    // syncToGoogleTasks(item.title, false);
                }
            }

            recordHistory();
            updateUI();
        }

        // ★修正版：ボタンを押した瞬間に画面を更新して色を変える関数
        function toggleChallengeDate(subjId, dateStr, forceState) {
            const subj = appData.subjects[subjId];
            if (!subj) return;

            // データの保存（ON/OFF切り替え）
            if (forceState) {
                subj.challengeHistory[dateStr] = true;
            } else {
                delete subj.challengeHistory[dateStr];
            }
            saveData();

            // ★重要：ここで習慣リストを再描画して、ボタンの色を即座に変える
            if (document.getElementById('challenge-screen').classList.contains('active')) {
                renderChallengeScreen();
            }

            // 他の画面（進捗グラフやカレンダー）も同期させる
            // updateUI(); // ※もし動作が重い場合はこの行をコメントアウトしてもOK

            // ヘッダーの連続日数表示などを更新するために必要
            updateHeaderDate();
            updateExamDaysDisplay();
            // updateUI() の中身の一部を手動実行して軽量化
            const isChallenge = appData.currentSubjectId !== ALL_SUBJECTS_ID && appData.subjects[appData.currentSubjectId]?.type === 'challenge';
            if (isChallenge) {
                const stats = calculateChallengeStats(subj);
                const streakText = stats.currentStreak === 0 ? getStreakMessage(0) : `${stats.currentStreak}日連続継続中！`;
                document.getElementById('streak-count-header').textContent = streakText;
            }
        }

        // ★修正版：画面サイズに合わせて伸縮し、見やすさを向上させたカレンダー描画
        function renderCalendar() {
            const grid = document.getElementById('calendar-grid');
            const title = document.getElementById('calendar-title');
            grid.innerHTML = '';

            const year = currentCalendarDate.getFullYear();
            const month = currentCalendarDate.getMonth();
            title.textContent = `${year}年 ${month + 1}月`;

            const firstDay = new Date(year, month, 1).getDay();
            const lastDate = new Date(year, month + 1, 0).getDate();

            // 前月の日付埋め（空白ではなく薄いグレーで表示する場合）
            // 今回はシンプルに空白セルで埋めますが、枠線は描画します
            const totalCells = 42; // 6週間分確保してレイアウト崩れを防ぐ

            updateCalendarLegend();

            // カレンダー生成ループ
            for (let i = 0; i < totalCells; i++) {
                const dayNum = i - firstDay + 1;
                const cell = document.createElement('div');

                // セルの基本スタイル（枠線、伸縮設定）
                cell.className = "border-b border-r border-gray-700/50 relative p-1 flex flex-col items-center hover:bg-white/5 transition-colors cursor-pointer group min-h-[50px]";

                // 右端の枠線を消す（親の枠があるため）
                if ((i + 1) % 7 === 0) cell.classList.remove('border-r');
                // 最下段の枠線を消す
                if (i >= 35) cell.classList.remove('border-b');

                if (dayNum > 0 && dayNum <= lastDate) {
                    const dateObj = new Date(year, month, dayNum);
                    const dateStr = formatDate(dateObj);
                    const isToday = dateStr === getTodayStr();

                    // --- 日付数字のデザイン ---
                    const daySpan = document.createElement('span');
                    daySpan.className = `text-sm font-bold w-6 h-6 flex items-center justify-center rounded-full mb-1 z-10 ${isToday
                        ? 'bg-app-accent text-app-dark shadow-lg ring-2 ring-app-accent/30'
                        : 'text-gray-300 group-hover:bg-gray-700'
                        }`;
                    daySpan.textContent = dayNum;
                    cell.appendChild(daySpan);

                    // --- データの判定 ---
                    const currentId = appData.currentSubjectId;
                    const isAll = currentId === ALL_SUBJECTS_ID;
                    const currentSubj = appData.subjects[currentId];
                    const isStudyMode = isAll || (currentSubj && currentSubj.type === 'study');
                    const isChallengeMode = !isAll && (currentSubj && currentSubj.type === 'challenge');

                    let marksContainer = document.createElement('div');
                    marksContainer.className = "flex flex-wrap justify-center gap-0.5 w-full px-1";

                    // 1. 目標日フラグ
                    if (isStudyMode) {
                        const subjects = isAll ? getActiveSubjects() : [currentSubj];
                        const examSubjs = subjects.filter(s => s.examDate && formatDate(new Date(s.examDate)) === dateStr);
                        if (examSubjs.length > 0) {
                            const flag = document.createElement('div');
                            flag.className = "absolute top-1 right-1 animate-pulse";
                            flag.innerHTML = examSubjs.map(s => `<i class="fas fa-flag text-[10px] ${getSubjectColor(s.id)} filter drop-shadow"></i>`).join('');
                            cell.appendChild(flag);
                        }
                    }

                    // 2. 予定・完了マーク
                    if (isStudyMode) {
                        // 予定があるか
                        const hasEvent = (appData.schedules[dateStr] || []).some(t => {
                            const s = appData.subjects[t.subjectId];
                            if (!s || !s.isActive) return false;
                            return isAll ? s.type === 'study' : t.subjectId === currentId;
                        });

                        // 完了したものがあるか
                        let hasCompleted = false;
                        const subjects = isAll ? getActiveSubjects() : [currentSubj];
                        for (const s of subjects) {
                            if (s.syllabus && s.syllabus.some(u => u.completedDate === dateStr)) {
                                hasCompleted = true; break;
                            }
                        }

                        if (hasEvent) {
                            marksContainer.innerHTML += `<div class="w-1.5 h-1.5 rounded-full bg-app-accent mb-0.5"></div>`;
                        }
                        if (hasCompleted) {
                            marksContainer.innerHTML += `<div class="w-1.5 h-1.5 rounded-full bg-app-success mb-0.5"></div>`;
                        }
                    }

                    // 3. チャレンジ達成マーク
                    if (isChallengeMode && currentSubj.challengeHistory && currentSubj.challengeHistory[dateStr]) {
                        // チャレンジモードなら日付の背景を少し豪華にするか、大きな星をつける
                        marksContainer.innerHTML += `<i class="fas fa-star text-challenge-gold text-[10px] filter drop-shadow-md"></i>`;
                        cell.classList.add('bg-challenge-gold/5');
                    }

                    cell.appendChild(marksContainer);
                    cell.onclick = () => openDateModal(dateStr);
                } else {
                    // 日付がないセル（空セル）
                    cell.className += " bg-gray-900/30 cursor-default"; // 少し暗く
                }

                grid.appendChild(cell);
            }
        }

        function updateCalendarLegend() {
            const legendEl = document.getElementById('calendar-legend'); if (!legendEl) return;
            const subjectsWithGoal = getActiveSubjects().filter(s => s.examDate);
            let html = subjectsWithGoal.length > 0 ? `<span class="mr-2">※ 目標日の色:</span> ${subjectsWithGoal.map(s => `<span class="${getSubjectColor(s.id)} flex items-center gap-1"><i class="fas fa-flag text-[8px]"></i>${escapeHtml(s.name)}</span>`).join(' ')}` : '<span class="text-gray-600">※ 目標日は詳細から設定できます</span>';
            legendEl.innerHTML = html;
        }

        // ★追加：習慣チェック表を描画する関数
        function renderChallengeScreen() {
            const container = document.getElementById('challenge-matrix-container');
            const statsContainer = document.getElementById('challenge-stats-grid');

            const challenges = getActiveChallenges();

            if (challenges.length === 0) {
                container.innerHTML = '<div class="p-8 text-center text-xs text-gray-500">「管理」タブから<br>継続チャレンジを追加してください</div>';
                statsContainer.innerHTML = '';
                return;
            }

            // 日付ヘッダーの生成 (今日から6日前まで)
            const dates = [];
            const today = getToday();
            for (let i = 0; i < 7; i++) {
                const d = new Date(today);
                d.setDate(d.getDate() - i);
                dates.push(d);
            }
            // 表示順: 左(過去) -> 右(今日) にするか、左(今日) -> 右(過去) にするか
            // 直近を見たいので 左(今日) -> 右(過去) の順で並べます

            let html = '<table class="challenge-table"><thead><tr>';
            html += '<th class="challenge-th" style="width: 30%;">項目</th>';

            dates.forEach(d => {
                const isToday = formatDate(d) === getTodayStr();
                const dStr = `${d.getMonth() + 1}/${d.getDate()}`;
                const week = ['日', '月', '火', '水', '木', '金', '土'][d.getDay()];
                html += `<th class="challenge-th ${isToday ? 'today' : ''}">${dStr}<br><span class="text-[9px]">${week}</span></th>`;
            });
            html += '</tr></thead><tbody>';

            // 各チャレンジの行生成
            challenges.forEach(subj => {
                html += `<tr class="challenge-row">`;
                html += `<td class="challenge-name-cell">${escapeHtml(subj.name)}</td>`;

                dates.forEach(d => {
                    const dateStr = formatDate(d);
                    const isDone = !!subj.challengeHistory[dateStr];
                    const isToday = dateStr === getTodayStr();

                    let btnClass = isDone ? 'check-btn checked' : 'check-btn';
                    if (isToday && !isDone) btnClass += ' today-incomplete'; // 今日未完了なら赤枠

                    html += `<td class="challenge-check-cell">
                        <button onclick="toggleChallengeDate('${subj.id}', '${dateStr}', ${!isDone})" class="${btnClass}">
                            <i class="fas fa-check"></i>
                        </button>
                    </td>`;
                });
                html += '</tr>';
            });
            html += '</tbody></table>';
            container.innerHTML = html;

            // 継続日数の表示
            statsContainer.innerHTML = '';
            challenges.forEach(subj => {
                const stats = calculateChallengeStats(subj);
                statsContainer.innerHTML += `
                    <div class="bg-gray-800 p-3 rounded border border-gray-700 flex justify-between items-center">
                        <span class="text-[10px] text-gray-300 font-bold truncate pr-2">${escapeHtml(subj.name)}</span>
                        <div class="text-right">
                            <span class="text-lg font-bold text-challenge-gold">${stats.currentStreak}</span>
                            <span class="text-[9px] text-gray-500">日連続</span>
                        </div>
                    </div>`;
            });
        }

        // ★追加：タブ切り替え用のヘルパー関数
        function switchTab(targetId) {
            // コンテンツの表示切り替え
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById(targetId).classList.add('active');
            document.getElementById('main-container').scrollTop = 0;

            // もしクリックしたのが通常のnav-btnなら色をつける（中央ボタンは色固定なので無視）
            const clickedBtn = document.querySelector(`.nav-btn[data-target="${targetId}"]`);
            if (clickedBtn) {
                clickedBtn.classList.replace('text-gray-500', 'text-app-accent');
            }

            // 画面ごとの描画更新
            if (targetId === 'challenge-screen') {
                renderChallengeScreen();
                loadSleepLogDate();
                // 少し遅延させて描画することで、display:block反映後のサイズを取得させる
                setTimeout(renderSleepChart, 50);
            }
            if (targetId === 'manage-screen') {
                renderManageScreen();
                renderTickerSettings();
            }
            if (targetId === 'record-screen') renderRecordLists();
            if (targetId === 'home-screen') updateUI(); // ホームに戻った時も更新
        }

        // ★修正版：総合モードでも全科目のリストを表示して編集できるようにする
        function renderManageScreen() {
            const list = document.getElementById('manage-subject-list');
            list.innerHTML = '';

            // ★変更点：ここで「総合モードならreturn」していた処理を削除しました

            const active = [], challenges = [], inactive = [];

            // 全ての科目を分類
            Object.values(appData.subjects).forEach(s => {
                if (!s.isActive) inactive.push(s);
                else if (s.type === 'challenge') challenges.push(s);
                else active.push(s);
            });

            // 行を作成するヘルパー関数
            const createRow = (s) => `
                <div class="flex justify-between items-center bg-gray-800 p-3 rounded border border-gray-700 mb-2">
                    <div>
                        <div class="text-sm font-bold text-white">${escapeHtml(s.name)}</div>
                        </div>
                    <div class="flex gap-2">
                        <button onclick="toggleSubjectActive('${escapeHtml(s.id)}')" class="text-xs ${s.isActive ? 'text-gray-400' : 'text-app-accent'}">
                            <i class="fas ${s.isActive ? 'fa-archive' : 'fa-box-open'}"></i>
                        </button>
                        <button onclick="${s.type === 'challenge' ? `editChallenge('${escapeHtml(s.id)}')` : `editSubject('${escapeHtml(s.id)}')`}" class="text-xs bg-gray-700 text-white px-2 py-1 rounded border border-gray-600">編集</button>
                        <button onclick="deleteSubjectRequest('${escapeHtml(s.id)}')" class="text-xs bg-red-900/30 text-red-200 px-2 py-1 rounded border border-red-900/50"><i class="fas fa-trash"></i></button>
                    </div>
                </div>`;

            // リスト描画
            if (active.length) list.innerHTML += `<h4 class="text-xs text-gray-500 font-bold mb-2 pl-1">学習科目</h4>` + active.map(createRow).join('');
            if (challenges.length) list.innerHTML += `<h4 class="text-xs text-gray-500 font-bold mb-2 mt-4 pl-1">チャレンジ</h4>` + challenges.map(createRow).join('');
            if (inactive.length) list.innerHTML += `<h4 class="text-xs text-gray-500 font-bold mb-2 mt-4 pl-1 text-gray-600">アーカイブ (未学習)</h4>` + inactive.map(createRow).join('');

            renderTickerSettings(); // ティッカー設定も更新

            if (active.length + challenges.length + inactive.length === 0) {
                list.innerHTML = '<p class="text-center text-xs text-gray-500 py-4">科目がありません。<br>下から追加してください。</p>';
            }
        }

        // --- HANDLERS ---
        function addNewSubject(type) {
            const nameInput = document.getElementById(type === 'challenge' ? 'new-challenge-name' : 'new-subject-name');
            const name = nameInput.value.trim(); if (!name) return;
            const id = 'subj_' + Date.now();
            if (type === 'challenge') appData.subjects[id] = { id, type: 'challenge', name, examDate: null, startDate: getTodayStr(), isActive: true, challengeHistory: {} };
            else appData.subjects[id] = { id, type: 'study', name, examDate: null, startDate: null, isActive: true, history: {}, syllabus: [] };
            nameInput.value = ''; saveData(); updateUI(); showToast('追加しました');
        }
        function toggleSubjectActive(id) { if (appData.subjects[id]) { appData.subjects[id].isActive = !appData.subjects[id].isActive; saveData(); updateUI(); } }
        function deleteSubjectRequest(id) { showAppConfirm("削除確認", `「${appData.subjects[id].name}」を完全に削除しますか？`, () => { delete appData.subjects[id]; if (appData.currentSubjectId === id) appData.currentSubjectId = ALL_SUBJECTS_ID; saveData(); updateUI(); }); }
        function editSubject(id) { editingSubjectId = id; document.getElementById('edit-subject-name-input').value = appData.subjects[id].name; document.getElementById('unit-editor-area').classList.remove('hidden'); document.getElementById('challenge-editor-area').classList.add('hidden'); renderUnitList(); resetUnitInput(); }

        function editChallenge(id) {
            editingSubjectId = id;
            const s = appData.subjects[id];
            document.getElementById('edit-challenge-name').value = s.name;
            document.getElementById('edit-challenge-start').value = s.startDate || '';
            document.getElementById('edit-challenge-end').value = s.examDate || '';

            // 自動チェック設定の反映
            const autoType = s.autoCheckType || '';
            document.getElementById('edit-challenge-auto-type').value = autoType;
            document.getElementById('edit-challenge-target-time').value = s.autoCheckTime || '';
            toggleAutoTimeInput();

            document.getElementById('challenge-editor-area').classList.remove('hidden');
            document.getElementById('unit-editor-area').classList.add('hidden');
        }

        function updateSubjectName() { const n = document.getElementById('edit-subject-name-input').value.trim(); if (n) { appData.subjects[editingSubjectId].name = n; saveData(); updateUI(); } }

        function saveChallengeSettings() {
            const s = appData.subjects[editingSubjectId];
            s.name = document.getElementById('edit-challenge-name').value;
            s.startDate = document.getElementById('edit-challenge-start').value || null;
            s.examDate = document.getElementById('edit-challenge-end').value || null;

            // 自動チェック設定の保存
            s.autoCheckType = document.getElementById('edit-challenge-auto-type').value;
            s.autoCheckTime = document.getElementById('edit-challenge-target-time').value;

            saveData();
            updateUI();
            document.getElementById('challenge-editor-area').classList.add('hidden');
        }

        function toggleAutoTimeInput() {
            const type = document.getElementById('edit-challenge-auto-type').value;
            const area = document.getElementById('auto-time-input-area');
            const input = document.getElementById('edit-challenge-target-time');
            const help = document.getElementById('auto-time-help-text');

            if (type) {
                area.classList.remove('hidden');
                if (type === 'study_time') {
                    input.type = 'number';
                    input.placeholder = '60 (分)';
                    help.textContent = '※目標とする勉強時間を「分」で入力してください (例: 1時間なら60)';
                } else {
                    input.type = 'time';
                    input.placeholder = '';
                    help.textContent = '※目標とする時刻を入力してください';
                }
            } else {
                area.classList.add('hidden');
            }
        }

        function closeUnitEditor() { document.getElementById('unit-editor-area').classList.add('hidden'); }
        function closeChallengeEditor() { document.getElementById('challenge-editor-area').classList.add('hidden'); }
        // ★修正版：チェックボックス付きの単元リスト生成関数
        // ★修正版：「既遂」の文字を表示するようにしたリスト描画関数
        function renderUnitList() {
            const list = document.getElementById('manage-unit-list');
            list.innerHTML = '';
            const subj = appData.subjects[editingSubjectId];

            const allCheck = document.getElementById('select-all-units');
            if (allCheck) allCheck.checked = false;

            if (!subj || !subj.syllabus) return;

            subj.syllabus.forEach((item, idx) => {
                const div = document.createElement('div');
                div.className = `flex justify-between items-center bg-gray-900 p-2 rounded border border-gray-800 text-[10px] ${idx === editingUnitIndex ? 'border-app-accent bg-gray-800' : ''}`;

                let statusIcon = '<i class="far fa-circle text-gray-600"></i>';
                if (item.status === 'completed') {
                    statusIcon = '<i class="fas fa-check-circle text-app-success"></i>';
                }

                const lapBadge = item.lapCount > 0 ? `<span class="bg-gray-700 text-gray-300 px-1.5 rounded-full text-[9px] ml-1">x${item.lapCount}</span>` : '';
                const weakIndicator = item.isWeak ? '<i class="fas fa-exclamation-triangle text-app-weak text-[9px] ml-1"></i>' : '';

                // ★追加：完了日または「既遂」の表示
                let dateDisplay = '';
                if (item.status === 'completed') {
                    const dateText = (item.completedDate === 'initial') ? '既遂' : (item.completedDate ? item.completedDate.substring(5).replace('-', '/') : '');
                    dateDisplay = `<span class="text-[9px] text-gray-500 ml-2">(${dateText})</span>`;
                }

                div.innerHTML = `
                    <div class="flex items-center gap-2 flex-1 min-w-0">
                        <input type="checkbox" class="unit-select-checkbox accent-app-accent cursor-pointer" value="${idx}">
                        <div class="w-4 text-center">${statusIcon}</div>
                        <span class="truncate flex-1 cursor-pointer" onclick="editUnit(${idx})">
                            <span class="text-app-sub">[${escapeHtml(item.category)}]</span> ${escapeHtml(item.title)}
                            ${dateDisplay}
                            ${lapBadge}
                            ${weakIndicator}
                        </span>
                    </div>
                    <div class="flex gap-1 items-center">
                        <button onclick="editUnit(${idx})" class="text-gray-500 hover:text-white px-2 py-1"><i class="fas fa-pen"></i></button>
                        <button onclick="deleteUnitRequest(${idx})" class="text-gray-500 hover:text-red-400 px-2 py-1"><i class="fas fa-trash"></i></button>
                    </div>`;
                list.appendChild(div);
            });
        }
        // ★追加：カテゴリ一括変更のための関数群
        function toggleAllUnitChecks(source) {
            const checks = document.querySelectorAll('.unit-select-checkbox');
            checks.forEach(c => c.checked = source.checked);
        }

        // ★追加：統合された一括編集機能
        function openBulkEditModal() {
            const checks = document.querySelectorAll('.unit-select-checkbox:checked');
            if (checks.length === 0) {
                showToast("編集する単元を選択してください");
                return;
            }
            // 選択件数を表示してモーダルを開く
            document.getElementById('bulk-selected-count').textContent = checks.length;

            // 入力欄をリセット
            document.getElementById('bulk-edit-category').value = '';
            document.getElementById('bulk-edit-status').value = 'no-change';
            document.getElementById('bulk-edit-date').value = '';
            document.getElementById('bulk-edit-lap').value = '';
            toggleBulkDateInputInModal();

            document.getElementById('bulk-edit-modal').classList.remove('hidden');
        }

        function closeBulkEditModal() {
            document.getElementById('bulk-edit-modal').classList.add('hidden');
        }

        function toggleBulkDateInputInModal() {
            const val = document.getElementById('bulk-edit-status').value;
            const dateInput = document.getElementById('bulk-edit-date');
            if (val === 'completed_date') {
                dateInput.classList.remove('hidden');
            } else {
                dateInput.classList.add('hidden');
            }
        }

        function applyCombinedBulkEdit() {
            const checks = document.querySelectorAll('.unit-select-checkbox:checked');
            if (checks.length === 0) return;

            // 各入力値を取得
            const newCat = document.getElementById('bulk-edit-category').value.trim();
            const statusType = document.getElementById('bulk-edit-status').value;
            const dateVal = document.getElementById('bulk-edit-date').value;
            const lapVal = document.getElementById('bulk-edit-lap').value;

            // 何も入力されていない場合は警告
            if (!newCat && statusType === 'no-change' && lapVal === "") {
                showToast("変更内容を入力してください");
                return;
            }

            if (statusType === 'completed_date' && !dateVal) {
                showToast("完了日を選択してください");
                return;
            }

            if (!confirm(`選択した ${checks.length} 件の単元を一括変更しますか？`)) return;

            const subj = appData.subjects[editingSubjectId];
            let updateCount = 0;

            checks.forEach(c => {
                const idx = parseInt(c.value);
                const item = subj.syllabus[idx];
                if (!item) return;

                // 1. カテゴリ更新（入力がある場合のみ）
                if (newCat) {
                    item.category = newCat;
                }

                // 2. ステータス更新（「変更しない」以外の場合）
                if (statusType !== 'no-change') {
                    if (statusType === 'pending') {
                        item.status = 'pending';
                        item.completedDate = null;
                    } else if (statusType === 'initial') {
                        item.status = 'completed';
                        item.completedDate = 'initial';
                    } else {
                        // completed or completed_date
                        item.status = 'completed';
                        if (statusType === 'completed_date') {
                            item.completedDate = dateVal;
                        } else {
                            // 今日
                            item.completedDate = getTodayStr();
                        }
                    }
                }

                // 3. 周回数更新（入力がある場合のみ）
                if (lapVal !== "") {
                    item.lapCount = parseInt(lapVal);
                }

                updateCount++;
            });

            saveData();
            renderUnitList();
            closeBulkEditModal();
            showToast(`${updateCount}件を更新しました`);
            updateUI();
        }

        function toggleUnitWeak(idx) { const item = appData.subjects[editingSubjectId].syllabus[idx]; item.isWeak = !item.isWeak; saveData(); renderUnitList(); updateUI(); }
        // ★修正版：単体編集もモーダルで行うように変更
        function editUnit(idx) {
            editingUnitIndex = idx;
            const subj = appData.subjects[editingSubjectId];
            const item = subj.syllabus[idx];

            // モーダルに入力値をセット
            document.getElementById('single-edit-category').value = item.category;
            document.getElementById('single-edit-title').value = item.title;
            document.getElementById('single-edit-weak').checked = !!item.isWeak;
            document.getElementById('single-edit-lap').value = item.lapCount || 0;

            // ステータスの判定とセット
            const statusSel = document.getElementById('single-edit-status');
            const dateInput = document.getElementById('single-edit-date');

            if (item.status === 'completed') {
                if (item.completedDate === 'initial') {
                    statusSel.value = 'initial';
                } else {
                    // 日付が入っている場合、デフォルトは「日付指定」にしてその日付を入れる
                    statusSel.value = 'completed_date';
                    dateInput.value = item.completedDate;
                }
            } else {
                statusSel.value = 'pending';
            }

            toggleSingleEditDateInput(); // 日付欄の表示切替
            document.getElementById('single-unit-edit-modal').classList.remove('hidden');
        }

        // ★追加：単体編集モーダルの操作関数群
        function closeSingleUnitEditModal() {
            document.getElementById('single-unit-edit-modal').classList.add('hidden');
            editingUnitIndex = null;
        }

        function toggleSingleEditDateInput() {
            const val = document.getElementById('single-edit-status').value;
            const dateInput = document.getElementById('single-edit-date');
            if (val === 'completed_date') {
                dateInput.classList.remove('hidden');
            } else {
                dateInput.classList.add('hidden');
            }
        }

        function saveSingleUnitEdit() {
            const subj = appData.subjects[editingSubjectId];
            const item = subj.syllabus[editingUnitIndex];

            const cat = document.getElementById('single-edit-category').value.trim();
            const title = document.getElementById('single-edit-title').value.trim();

            if (!cat || !title) {
                showToast("カテゴリと単元名は必須です");
                return;
            }

            // 値を更新
            item.category = cat;
            item.title = title;
            item.isWeak = document.getElementById('single-edit-weak').checked;
            item.lapCount = parseInt(document.getElementById('single-edit-lap').value) || 0;

            const statusType = document.getElementById('single-edit-status').value;
            const dateVal = document.getElementById('single-edit-date').value;

            // ステータス更新ロジック
            if (statusType === 'pending') {
                item.status = 'pending';
                item.completedDate = null;
            } else if (statusType === 'initial') {
                item.status = 'completed';
                item.completedDate = 'initial';
            } else {
                // completed
                item.status = 'completed';
                if (statusType === 'completed_date' && dateVal) {
                    item.completedDate = dateVal;
                } else {
                    // 「完了(今日)」が選ばれた、または日付指定で空欄だった場合は今日の日付
                    // ただし、既に完了済みで日付が変わらない場合は維持した方が親切かも？
                    // 今回は明示的に変更操作をしているので、選択に従います
                    if (statusType === 'completed') {
                        item.completedDate = getTodayStr();
                    } else if (item.completedDate && statusType === 'completed_date') {
                        // 既存の日付をキープ
                    } else {
                        item.completedDate = getTodayStr();
                    }
                }
            }

            saveData();
            renderUnitList();
            updateUI();
            closeSingleUnitEditModal();
            showToast("単元を更新しました");
        }

        // ★修正版：0日目完了を「日付」ではなく「既遂(initial)」として記録する関数
        function saveUnit() {
            const c = document.getElementById('new-unit-category').value.trim();
            const t = document.getElementById('new-unit-title').value.trim();
            if (!c || !t) return;

            const w = document.getElementById('new-unit-weak').checked;
            const lap = parseInt(document.getElementById('new-unit-lap').value) || 0;
            const statusType = document.getElementById('new-unit-status-select').value;

            const subj = appData.subjects[editingSubjectId];

            // 日付とステータスの決定
            let newStatus = 'pending';
            let newDate = null;
            let shouldCleanSchedule = false;

            if (statusType === 'completed') {
                newStatus = 'completed';
                // 編集前の日付があればそれを維持、なければ今日
                if (editingUnitIndex !== null && subj.syllabus[editingUnitIndex].completedDate) {
                    newDate = subj.syllabus[editingUnitIndex].completedDate;
                } else {
                    newDate = getTodayStr();
                }
            } else if (statusType === 'completed_init') {
                newStatus = 'completed';

                // 開始日がまだない場合、今日を開始日として登録
                if (!subj.startDate) {
                    subj.startDate = getTodayStr();
                }

                // ★修正点：日付ではなく「initial (既遂)」という特殊な値をセット
                newDate = "initial";

                shouldCleanSchedule = true;
            }

            // 追加または更新
            if (editingUnitIndex === null) {
                // 新規追加
                subj.syllabus.push({
                    id: `u_${Date.now()}`,
                    category: c,
                    title: t,
                    status: newStatus,
                    completedDate: newDate,
                    lapCount: lap,
                    isWeak: w
                });
            } else {
                // 既存更新
                const u = subj.syllabus[editingUnitIndex];

                if (shouldCleanSchedule) {
                    Object.keys(appData.schedules).forEach(date => {
                        appData.schedules[date] = appData.schedules[date].filter(task => task.unitId !== u.id);
                        if (appData.schedules[date].length === 0) delete appData.schedules[date];
                    });
                }

                u.category = c;
                u.title = t;
                u.isWeak = w;
                u.lapCount = lap;

                // ステータスや日付が変わる場合のみ更新
                if (statusType === 'completed_init') {
                    u.status = 'completed';
                    u.completedDate = "initial"; // 強制的に既遂扱い
                } else if (statusType === 'pending') {
                    u.status = 'pending';
                    u.completedDate = null;
                } else {
                    // 通常完了
                    if (u.status !== 'completed') {
                        u.status = 'completed';
                        u.completedDate = getTodayStr();
                    }
                    // 以前「既遂」だったものを「今日完了」に変更したい場合などのために
                    // ステータスタイプが 'completed' で、かつ現在 'initial' なら今日の日付で上書き
                    if (statusType === 'completed' && u.completedDate === 'initial') {
                        u.completedDate = getTodayStr();
                    }
                }
            }

            saveData();
            renderUnitList();
            resetUnitInput();
            updateUI();
        }
        function resetUnitInput() {
            editingUnitIndex = null;
            document.getElementById('new-unit-title').value = '';
            // カテゴリは連続入力しやすいよう残してもいいが、一旦クリアしない実装ならそのままでOK
            // ここではタイトルだけクリアしておきます
            document.getElementById('new-unit-weak').checked = false;
            document.getElementById('new-unit-lap').value = 0;
            document.getElementById('new-unit-status-select').value = 'pending';

            document.getElementById('add-update-unit-btn').textContent = '追加';
            document.getElementById('cancel-edit-unit-btn').classList.add('hidden');
        }
        function cancelEditUnit() { resetUnitInput(); }
        function deleteUnitRequest(idx) { showAppConfirm("削除確認", "削除しますか？", () => { appData.subjects[editingSubjectId].syllabus.splice(idx, 1); saveData(); renderUnitList(); updateUI(); }); }

        // ★修正版：長い単元名でもレイアウト崩れしない予定追加モーダル
        // ★修正版：HTML側の構造に合わせてシンプルにした予定追加モーダル
        function openDateModal(dateStr) {
            selectedDateString = dateStr;
            document.getElementById('modal-date-title').textContent = formatShortDate(new Date(dateStr));

            const isChallenge = appData.currentSubjectId !== ALL_SUBJECTS_ID && appData.subjects[appData.currentSubjectId]?.type === 'challenge';
            document.getElementById('modal-study-content').style.display = isChallenge ? 'none' : 'block';
            document.getElementById('modal-challenge-content').style.display = isChallenge ? 'block' : 'none';

            if (isChallenge) {
                const subj = appData.subjects[appData.currentSubjectId]; const isDone = !!subj.challengeHistory[dateStr];
                document.getElementById('modal-challenge-status').textContent = `チャレンジ: ${subj.name}`;
                const btn = document.getElementById('toggle-challenge-date-btn'); btn.className = isDone ? "w-full py-3 bg-red-900 text-red-200 rounded-lg" : "w-full py-3 bg-challenge-gold text-app-dark rounded-lg";
                btn.textContent = isDone ? "取り消す" : "達成済みにする"; btn.onclick = () => { toggleChallengeDate(subj.id, dateStr, !isDone); closeModal(); };
            } else {
                const isAll = appData.currentSubjectId === ALL_SUBJECTS_ID; document.getElementById('set-exam-btn').style.display = isAll ? 'none' : 'block';
                if (!isAll) { const s = appData.subjects[appData.currentSubjectId]; const isSet = s.examDate === dateStr; document.getElementById('exam-btn-text').textContent = isSet ? '目標解除' : '目標設定'; document.getElementById('set-exam-btn').onclick = () => { s.examDate = isSet ? null : dateStr; if (!isSet && !s.startDate) s.startDate = getTodayStr(); saveData(); updateUI(); closeModal(); }; }
                const comp = document.getElementById('modal-completed-list'); comp.innerHTML = ''; (isAll ? getActiveSubjects() : [appData.subjects[appData.currentSubjectId]]).forEach(s => { (s.syllabus || []).forEach(u => { if (u.completedDate === dateStr) comp.innerHTML += `<div class="text-[10px] mb-1 truncate">✔ [${escapeHtml(s.name)}] ${escapeHtml(u.title)}</div>`; }); });

                const taskList = document.getElementById('modal-task-list');
                taskList.innerHTML = "";
                const currentSchedule = appData.schedules[dateStr] || [];

                currentSchedule.forEach((t, i) => {
                    const s = appData.subjects[t.subjectId];
                    const u = s?.syllabus.find(x => x.id === t.unitId);
                    if (u) {
                        const isDone = u.status === 'completed';
                        taskList.innerHTML += `
                        <div class="flex justify-between items-center p-2 text-xs border-b border-gray-800 ${isDone ? 'opacity-50' : ''}">
                            <span class="flex-1 min-w-0 truncate mr-2 ${isDone ? 'line-through' : ''}">[${escapeHtml(s.name)}] ${escapeHtml(u.title)}</span>
                            <button onclick="removeTaskFromDate('${dateStr}', ${i})" class="text-red-400 shrink-0"><i class="fas fa-trash-alt"></i></button>
                        </div>`;
                    }
                });

                const sel = document.getElementById('unit-selector');
                sel.innerHTML = '<option value="">単元追加...</option>';
                // ★以前のコードでここにあった sel.className = ... の行は削除しました（HTML側で設定済みのため）

                const pendingGroup = document.createElement('optgroup');
                pendingGroup.label = "未完了の単元";
                pendingGroup.className = "text-white bg-gray-900";

                const completedGroup = document.createElement('optgroup');
                completedGroup.label = "完了済み (復習・周回)";
                completedGroup.className = "text-app-success bg-gray-900";

                getCurrentSyllabus().forEach(u => {
                    const sId = u._subjectId || appData.currentSubjectId;
                    const sName = u._subjectName || appData.subjects[sId].name;
                    const isAlreadyScheduled = currentSchedule.some(t => t.subjectId === sId && t.unitId === u.id);

                    if (!isAlreadyScheduled) {
                        const option = document.createElement('option');
                        option.value = `${sId}:${u.id}`;

                        if (u.status === 'pending') {
                            option.textContent = `[${sName}] ${u.title}`;
                            pendingGroup.appendChild(option);
                        } else {
                            const lap = u.lapCount || 1;
                            option.textContent = `[${sName}] ${u.title} (現在: ${lap}周)`;
                            completedGroup.appendChild(option);
                        }
                    }
                });

                if (pendingGroup.children.length > 0) sel.appendChild(pendingGroup);
                if (completedGroup.children.length > 0) sel.appendChild(completedGroup);
            }
            document.getElementById('date-modal').classList.remove('hidden');
        }

        function closeModal() { document.getElementById('date-modal').classList.add('hidden'); }
        function removeTaskFromDate(d, i) { appData.schedules[d].splice(i, 1); saveData(); openDateModal(d); updateUI(); }
        // ★変更：同期処理を追加した予定登録関数
        function addUnitToDate() {
            const v = document.getElementById('unit-selector').value;
            if (!v) return;

            const [sid, uid] = v.split(':');

            // アプリ内データの更新
            if (!appData.schedules[selectedDateString]) {
                appData.schedules[selectedDateString] = [];
            }
            appData.schedules[selectedDateString].push({ subjectId: sid, unitId: uid });
            saveData();

            // ★ここが追加部分：Google ToDoへ同期
            const targetSubj = appData.subjects[sid];
            const targetUnit = targetSubj?.syllabus.find(x => x.id === uid);
            if (targetUnit) {
                addToGoogleTasks(targetUnit.title, selectedDateString);
            }

            openDateModal(selectedDateString);
            updateUI();
        }
        // ★修正版：期限切れならその場で再接続してくれる同期関数
        function syncFromGoogleTasks() {
            // トークンがない場合
            if (!googleAccessToken) {
                // 自動で再ログインを試みるか聞く
                if (confirm("Google連携の接続が切れています。\n再接続（ログイン）しますか？")) {
                    performGoogleLogin();
                }
                return;
            }

            showToast("Google ToDoから同期中...");
            fetch('https://tasks.googleapis.com/tasks/v1/lists/@default/tasks?showCompleted=true&showHidden=true', {
                headers: { 'Authorization': `Bearer ${googleAccessToken}` }
            })
                .then(response => {
                    if (response.status === 401) {
                        // 401エラー（期限切れ）の場合も再ログインへ誘導
                        throw new Error("AUTH_EXPIRED");
                    }
                    return response.json();
                })
                .then(data => {
                    if (!data.items) {
                        showToast("同期するタスクはありませんでした");
                        return;
                    }
                    // ...（中略：変更なし）...
                    let updatedCount = 0;
                    const todayStr = getTodayStr();

                    data.items.forEach(gTask => {
                        if (gTask.title.startsWith("[学習] ")) {
                            const unitTitle = gTask.title.replace("[学習] ", "");
                            const isCompletedInGoogle = (gTask.status === 'completed');
                            let taskCompletedDate = null;
                            if (gTask.completed) {
                                taskCompletedDate = formatDate(new Date(gTask.completed));
                            }
                            Object.values(appData.subjects).forEach(subj => {
                                if (subj.type === 'study' && subj.syllabus) {
                                    const unit = subj.syllabus.find(u => u.title === unitTitle);
                                    if (unit && isCompletedInGoogle && unit.status === 'pending' && taskCompletedDate === todayStr) {
                                        unit.status = 'completed';
                                        unit.completedDate = taskCompletedDate;
                                        updatedCount++;
                                    }
                                }
                            });
                        }
                    });

                    if (updatedCount > 0) {
                        saveData();
                        updateUI();
                        showToast(`${updatedCount}個の単元を同期しました`);
                    } else {
                        showToast("新しい完了タスクはありません");
                    }
                })
                .catch(err => {
                    if (err.message === "AUTH_EXPIRED" || err.message.includes("401")) {
                        if (confirm("接続の有効期限が切れました。\n再接続しますか？")) {
                            performGoogleLogin();
                        }
                    } else {
                        console.error("Sync error:", err);
                        showToast("同期エラーが発生しました");
                    }
                });
        }
        function openSettingsModal() {
            document.getElementById('settings-modal').classList.remove('hidden');
            updateThemeBtn(document.documentElement.classList.contains('light-mode'));
            // バージョン番号を反映
            const vDisplay = document.getElementById('app-version-display');
            if (vDisplay && typeof APP_VERSION !== 'undefined') vDisplay.textContent = APP_VERSION;
        }
        function closeSettingsModal() { document.getElementById('settings-modal').classList.add('hidden'); }
        function requestReset() { showAppConfirm("全リセット", "全てのデータを消去しますか？", () => { appData = getBlankData(); saveData(); updateUI(); closeSettingsModal(); }); }
        function exportData() { const blob = new Blob([JSON.stringify(appData)], { type: "application/json" }); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `backup_${getTodayStr()}.json`; a.click(); }
        // 復活: ファイルインポート機能
        function importData(input) { const reader = new FileReader(); reader.onload = (e) => { appData = migrateData(JSON.parse(e.target.result)); saveData(); updateUI(); showToast('復元しました'); }; reader.readAsText(input.files[0]); }
        function copyForKeep() {
            const d = formatDate(currentRecordDate); const tasks = appData.schedules[d] || [];
            let text = `【${d} の記録】\n`; tasks.forEach(task => { const s = appData.subjects[task.subjectId]; const u = s?.syllabus.find(x => x.id === task.unitId); if (u) text += `${u.status === 'completed' ? '☑' : '☐'} [${s.name}] ${u.title}\n`; });
            copyTextToClipboard(text); showToast('コピーしました');
        }

        // 復活: Gemini(AI)連携機能
        function copyPrompt() {
            const text = document.getElementById('gemini-prompt-template').value;
            copyTextToClipboard(text);
            showToast("テンプレートをコピーしました");
        }

        function importFromGemini() {
            const input = document.getElementById('gemini-json-input');
            const jsonStr = input.value.trim();
            if (!jsonStr) return;
            try {
                const data = JSON.parse(jsonStr);
                if (!data.name || !data.syllabus) throw new Error("形式が正しくありません");

                const id = 'subj_' + Date.now();
                const newSubj = {
                    id: id,
                    type: 'study',
                    name: data.name,
                    examDate: null,
                    startDate: getTodayStr(),
                    isActive: true,
                    history: {},
                    syllabus: data.syllabus.map((item, i) => ({
                        id: `u_${Date.now()}_${i}`,
                        category: item.category,
                        title: item.title,
                        status: 'pending',
                        isWeak: false
                    }))
                };
                appData.subjects[id] = newSubj;
                saveData();
                updateUI();
                input.value = '';
                showToast(`「${data.name}」を取り込みました`);
            } catch (e) {
                alert("JSONの読み込みに失敗しました: " + e.message);
            }
        }

        function importTickerData() {
            const input = document.getElementById('ticker-json-input');
            const jsonStr = input.value.trim();
            if (!jsonStr) return;
            try {
                const data = JSON.parse(jsonStr);
                if (!data.categories || !data.messages) throw new Error("形式が正しくありません");

                let addedCategories = 0;
                let updatedCategories = 0;
                let addedMessages = 0;

                // Merge categories
                data.categories.forEach(newCat => {
                    if (!newCat.id || !newCat.name) return; // Basic validation
                    const existingCatIndex = appData.ticker.categories.findIndex(c => c.id === newCat.id);
                    if (existingCatIndex > -1) {
                        // Update existing category
                        appData.ticker.categories[existingCatIndex] = { ...appData.ticker.categories[existingCatIndex], ...newCat };
                        updatedCategories++;
                    } else {
                        // Add new category
                        appData.ticker.categories.push(newCat);
                        addedCategories++;
                    }
                });

                // Merge messages
                data.messages.forEach(newMsg => {
                    if (!newMsg.categoryId || !newMsg.text) return; // Basic validation
                    const isDuplicate = appData.ticker.messages.some(m => m.categoryId === newMsg.categoryId && m.text === newMsg.text);
                    if (!isDuplicate) {
                        appData.ticker.messages.push(newMsg);
                        addedMessages++;
                    }
                });

                saveData();
                renderTickerSettings();
                initTicker(); // Restart ticker
                input.value = '';
                showToast(`カテゴリ: ${addedCategories}件追加, ${updatedCategories}件更新. メッセージ: ${addedMessages}件追加`);
            } catch (e) {
                alert("JSONの読み込みに失敗しました: " + e.message);
            }
        }
        function resetTickerData() {
            if (confirm("ティッカーデータを初期化しますか？")) {
                appData.ticker = JSON.parse(JSON.stringify(defaultTicker));
                saveData();
                renderTickerSettings();
                initTicker();
                showToast("初期化しました");
            }
        }

        function copyLongTermPrompt() {
            const subjects = getActiveSubjects().map(s => `${s.name} (目標: ${s.examDate || '未定'})`).join(', ');
            const text = `以下の科目の長期学習計画を立ててください。\n現在日: ${getTodayStr()}\n科目: ${subjects}\n\n条件:\n- 試験日から逆算して月ごとのマイルストーンを提示\n- 優先順位をつけること`;
            copyTextToClipboard(text);
            document.getElementById('gemini-copy-feedback').classList.remove('hidden');
            setTimeout(() => document.getElementById('gemini-copy-feedback').classList.add('hidden'), 3000);
        }

        function copyDailyPrompt() {
            const pending = getCurrentSyllabus().filter(i => i.status === 'pending').slice(0, 10).map(i => i.title).join(', ');
            const text = `今日の学習スケジュールを作成してください。\n現在日: ${getTodayStr()}\n優先的にやるべき単元候補: ${pending}\n\n条件:\n- 休憩を含めた現実的な時間割\n- 集中力が高い午前中に重いタスク`;
            copyTextToClipboard(text);
            document.getElementById('gemini-copy-feedback').classList.remove('hidden');
            setTimeout(() => document.getElementById('gemini-copy-feedback').classList.add('hidden'), 3000);
        }

        function copyReportPrompt() {
            const todayStr = getTodayStr();
            const done = [];
            getActiveSubjects().forEach(s => {
                s.syllabus.forEach(u => {
                    if (u.completedDate === todayStr) done.push(`[${s.name}] ${u.title}`);
                });
            });
            const text = `今日の学習報告です。\n実施日: ${todayStr}\n完了した単元:\n${done.join('\n') || 'なし'}\n\nこの内容で褒めて、次のモチベーションにつながるアドバイスをください。`;
            copyTextToClipboard(text);
            document.getElementById('gemini-copy-feedback').classList.remove('hidden');
            setTimeout(() => document.getElementById('gemini-copy-feedback').classList.add('hidden'), 3000);
        }

        // --- CHART & UPDATE UI ---
        // ★修正版：「既遂(initial)」を初期進捗としてグラフに反映させる関数
        function updatePaceChart(isChallenge) {
            const chartCanvas = document.getElementById('paceChart');
            if (!chartCanvas) return;

            const labels = [], actual = [], ideal = [], trend = [];
            let start, end;
            const today = getToday();

            let initialPercent = 0;

            if (appData.currentSubjectId === ALL_SUBJECTS_ID) {
                const dates = new Set();
                getActiveSubjects().forEach(s => {
                    Object.keys(s.history).forEach(d => dates.add(d));
                    if (s.startDate) dates.add(s.startDate);
                });
                dates.add(getTodayStr());
                const sorted = Array.from(dates).sort();
                if (sorted.length === 0) return;
                start = new Date(sorted[0]);

                let maxE = 0;
                getActiveSubjects().forEach(s => { if (s.examDate) maxE = Math.max(maxE, new Date(s.examDate).getTime()); });
                end = maxE > 0 ? new Date(maxE) : null;
                initialPercent = 0;

            } else {
                const s = appData.subjects[appData.currentSubjectId];
                if (!s) return;

                start = s.startDate ? new Date(s.startDate) : getToday();
                end = s.examDate ? new Date(s.examDate) : null;

                if (!isChallenge && s.syllabus && s.syllabus.length > 0) {
                    const startDateStr = formatDate(start);

                    // ★修正：「initial」または「開始日以前に完了したもの」を初期値としてカウント
                    const initialDoneCount = s.syllabus.filter(u =>
                        u.status === 'completed' &&
                        (u.completedDate === 'initial' || (u.completedDate && u.completedDate <= startDateStr))
                    ).length;

                    initialPercent = Math.round((initialDoneCount / s.syllabus.length) * 100);
                }
            }

            const dispEnd = (end && end > today) ? end : today;
            let cursor = new Date(start);
            let dayIdx = 0;
            const points = [];

            while (cursor <= dispEnd) {
                const dStr = formatDate(cursor);
                labels.push(formatShortDate(cursor));

                if (cursor <= today) {
                    let val = 0;
                    if (isChallenge) {
                        const s = appData.subjects[appData.currentSubjectId];
                        const daysPassed = Math.floor((cursor - new Date(s.startDate)) / 86400000) + 1;
                        let done = 0;
                        for (let k in s.challengeHistory) { if (new Date(k) <= cursor && new Date(k) >= new Date(s.startDate)) done++; }
                        val = daysPassed > 0 ? Math.round((done / daysPassed) * 100) : 0;
                    } else {
                        if (appData.currentSubjectId === ALL_SUBJECTS_ID) {
                            let total = 0, count = 0;
                            getActiveSubjects().forEach(s => { total += getProgressAt(s, dStr); count++; });
                            val = count > 0 ? Math.round(total / count) : 0;
                        } else {
                            val = getProgressAt(appData.subjects[appData.currentSubjectId], dStr);
                        }
                        if (val < initialPercent) val = initialPercent;
                        points.push({ x: dayIdx, y: val });
                    }
                    actual.push(val);
                } else {
                    actual.push(null);
                }

                if (!isChallenge && end) {
                    const totalDays = (end - start) / 86400000;
                    const passed = (cursor - start) / 86400000;
                    if (totalDays > 0) {
                        const idealVal = initialPercent + (100 - initialPercent) * (passed / totalDays);
                        ideal.push(Math.min(100, idealVal));
                    } else {
                        ideal.push(100);
                    }
                } else {
                    ideal.push(null);
                }

                cursor.setDate(cursor.getDate() + 1);
                dayIdx++;
            }

            if (!isChallenge) {
                const res = calculateLeastSquares(points);
                if (res) {
                    for (let i = 0; i < labels.length; i++) {
                        trend.push(Math.max(0, Math.min(100, res.slope * i + res.intercept)));
                    }
                }
            }

            paceChart.data.labels = labels;
            paceChart.data.datasets[0].data = ideal;
            paceChart.data.datasets[1].data = actual;

            // ★修正：ライトモード時のグラフ色調整
            const isLight = document.documentElement.classList.contains('light-mode');
            paceChart.data.datasets[0].borderColor = isLight ? '#0284c7' : '#38bdf8'; // 目標(青)
            paceChart.data.datasets[2].borderColor = isLight ? '#ea580c' : '#f97316'; // 予測(オレンジ)

            paceChart.data.datasets[1].borderColor = isChallenge ? '#fbbf24' : '#10b981';
            paceChart.data.datasets[1].backgroundColor = isChallenge ? 'rgba(251, 191, 36, 0.1)' : 'rgba(16, 185, 129, 0.1)';
            paceChart.data.datasets[2].data = trend;
            paceChart.update();
        }
        function updateUI() {
            refreshSubjectSelectUI();
            updateHeaderDate();
            updateExamDaysDisplay();

            const isLight = document.documentElement.classList.contains('light-mode');
            // ★修正：ライトモードの円グラフ背景を少し濃くして視認性アップ
            const circleBgColor = isLight ? '#cbd5e1' : '#1e293b';

            const isChallenge = appData.currentSubjectId !== ALL_SUBJECTS_ID && appData.subjects[appData.currentSubjectId]?.type === 'challenge';
            let percentage = 0;

            document.getElementById('current-subject-name-display').textContent = `表示中: ${appData.currentSubjectId === ALL_SUBJECTS_ID ? '総合' : appData.subjects[appData.currentSubjectId].name}`;
            document.getElementById('streak-count-header').textContent = '';
            document.getElementById('streak-count-mobile').textContent = '';
            document.getElementById('map-title').textContent = isChallenge ? '月別達成度' : '単元マップ';
            document.getElementById('map-legend').style.display = isChallenge ? 'none' : 'flex';
            document.getElementById('progress-label').textContent = isChallenge ? '実施率' : '進捗率';

            if (isChallenge) {
                const subj = appData.subjects[appData.currentSubjectId]; const stats = calculateChallengeStats(subj);
                percentage = stats.percentage;
                const streakText = stats.currentStreak === 0 ? getStreakMessage(0) : `${stats.currentStreak}日連続継続中！ ${getStreakMessage(stats.currentStreak)}`;
                document.getElementById('streak-count-header').textContent = streakText;
                document.getElementById('streak-count-mobile').textContent = streakText;
                renderMonthHeatmap(subj);
                progressCircleChart.data.datasets[0].backgroundColor = ['#fbbf24', circleBgColor];
                progressCircleChart.data.datasets[0].data = [percentage, 100 - percentage];
            } else {
                renderSlitBar();
                const syl = getCurrentSyllabus();
                const total = syl.length;
                if (total > 0) {
                    const completedNormal = syl.filter(u => u.status === 'completed' && !u.isWeak).length;
                    const completedWeak = syl.filter(u => u.status === 'completed' && u.isWeak).length;
                    percentage = Math.round(((completedNormal + completedWeak) / total) * 100);
                    const pNormal = Math.round((completedNormal / total) * 100);
                    const pWeak = Math.round((completedWeak / total) * 100);
                    const pRemaining = 100 - pNormal - pWeak;
                    progressCircleChart.data.datasets[0].backgroundColor = ['#10b981', '#fbbf24', circleBgColor];
                    progressCircleChart.data.datasets[0].data = [pNormal, pWeak, pRemaining];
                } else {
                    percentage = 0;
                    progressCircleChart.data.datasets[0].backgroundColor = ['#10b981', circleBgColor];
                    progressCircleChart.data.datasets[0].data = [0, 100];
                }
            }

            document.getElementById('total-progress-text').textContent = `${percentage}%`;
            progressCircleChart.update();

            renderRecordLists(); renderCalendar(); updatePaceChart(isChallenge); renderSleepChart(); loadSleepLogDate();
            if (document.getElementById('manage-screen').classList.contains('active')) renderManageScreen();
            document.body.style.opacity = 1;
        }

        const progressCircleChart = new Chart(document.getElementById('progressCircleChart').getContext('2d'), { type: 'doughnut', data: { datasets: [{ data: [0, 100], backgroundColor: ['#10b981', '#1e293b'], borderWidth: 0, cutout: '85%' }] }, options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false }, tooltip: { enabled: false } } } });
        const paceChart = new Chart(document.getElementById('paceChart').getContext('2d'), { type: 'line', data: { labels: [], datasets: [{ label: '目標', data: [], borderColor: '#38bdf8', borderWidth: 1, borderDash: [5, 5], pointRadius: 0, fill: false }, { label: '実績', data: [], borderColor: '#10b981', backgroundColor: 'rgba(16, 185, 129, 0.1)', borderWidth: 2, pointRadius: 2, fill: true, spanGaps: true }, { label: '予測', data: [], borderColor: '#f97316', borderWidth: 2, borderDash: [2, 2], pointRadius: 0, fill: false }] }, options: { responsive: true, maintainAspectRatio: false, scales: { x: { grid: { color: '#334155' }, ticks: { color: '#64748b', font: { size: 9 }, maxTicksLimit: 6 } }, y: { min: 0, max: 100, grid: { color: '#334155' }, ticks: { color: '#64748b', font: { size: 9 } } } }, plugins: { legend: { labels: { color: '#94a3b8', font: { size: 10 }, boxWidth: 10 } } } } });

        function updateChartColors() {
            const isLight = document.documentElement.classList.contains('light-mode');
            const gridColor = isLight ? '#cbd5e1' : '#334155';
            const textColor = isLight ? '#64748b' : '#94a3b8';

            if (paceChart && paceChart.options) {
                paceChart.options.scales.x.grid.color = gridColor;
                paceChart.options.scales.y.grid.color = gridColor;
                paceChart.options.scales.x.ticks.color = textColor;
                paceChart.options.scales.y.ticks.color = textColor;
                paceChart.options.plugins.legend.labels.color = textColor;
                paceChart.update();
            }
        }

        // --- Sleep Rhythm Logic ---
        let sleepChartRange = 7;

        function loadSleepLogDate() {
            const dateInput = document.getElementById('sleep-log-date');
            if (!dateInput.value) dateInput.value = getTodayStr(); // 初期値セット
            const dateStr = dateInput.value;

            const log = (appData.sleepLog && appData.sleepLog[dateStr]) || { wake: '', bed: '' };
            document.getElementById('sleep-log-wake').value = log.wake || '';
            document.getElementById('sleep-log-bed').value = log.bed || '';
        }

        function shiftSleepLogDate(diff) {
            const dateInput = document.getElementById('sleep-log-date');
            if (!dateInput.value) dateInput.value = getTodayStr();

            const current = new Date(dateInput.value);
            current.setDate(current.getDate() + diff);
            dateInput.value = formatDate(current);
            loadSleepLogDate();
        }

        function saveSleepLog(type) {
            const dateStr = document.getElementById('sleep-log-date').value;
            if (!dateStr) return;

            if (!appData.sleepLog) appData.sleepLog = {};
            if (!appData.sleepLog[dateStr]) appData.sleepLog[dateStr] = { wake: '', bed: '' };

            let msg = "";
            let updatedVal = "";

            if (type === 'wake') {
                const val = document.getElementById('sleep-log-wake').value;
                appData.sleepLog[dateStr].wake = val;
                msg = "起床時間を記録しました";
                updatedVal = val;
            } else if (type === 'bed') {
                const val = document.getElementById('sleep-log-bed').value;
                appData.sleepLog[dateStr].bed = val;
                msg = "就寝時間を記録しました";
                updatedVal = val;
            } else {
                // fallback for old calls (though now separate buttons)
                appData.sleepLog[dateStr].wake = document.getElementById('sleep-log-wake').value;
                appData.sleepLog[dateStr].bed = document.getElementById('sleep-log-bed').value;
                msg = "記録しました";
            }

            // 自動チェック判定
            // type指定がある場合は、それに関連するチェックのみ行うのが効率的だが
            // 既存関数は両方チェックするのでそのまま利用（副作用はない）
            checkSleepLogAutoChallenge(dateStr, appData.sleepLog[dateStr].wake, appData.sleepLog[dateStr].bed);

            saveData();
            renderSleepChart();
            showToast(msg);
        }

        function checkSleepLogAutoChallenge(dateStr, wake, bed) {
            const challenges = getActiveChallenges();
            let updated = false;

            challenges.forEach(c => {
                if (!c.autoCheckType || !c.autoCheckTime) return;

                let achieved = false;

                if (c.autoCheckType === 'waketime' && wake) {
                    const wakeMin = timeToMinutes(wake);
                    const targetMin = timeToMinutes(c.autoCheckTime);
                    if (wakeMin <= targetMin) achieved = true;
                } else if (c.autoCheckType === 'bedtime' && bed) {
                    const bedMin = timeToMinutes(bed, true);
                    const targetMin = timeToMinutes(c.autoCheckTime, true);
                    if (bedMin <= targetMin) achieved = true;
                }

                if (achieved) {
                    if (!c.challengeHistory) c.challengeHistory = {};
                    if (!c.challengeHistory[dateStr]) {
                        c.challengeHistory[dateStr] = true;
                        updated = true;
                    }
                }
            });

            if (updated) {
                renderChallengeScreen(); // Update the challenge table immediately
                showToast("目標達成！チャレンジを更新しました");
            }
        }

        function timeToMinutes(timeStr, isBedtime = false) {
            if (!timeStr) return 9999;
            const [h, m] = timeStr.split(':').map(Number);
            let total = h * 60 + m;
            // 就寝時間の場合、00:00-03:59 (深夜) は24:00-27:59 (翌日) として扱う
            // 今回はグラフ描画範囲の 04:00 ～ 28:00 に合わせる
            if (isBedtime && h < 4) total += 24 * 60;
            return total;
        }

        function changeSleepChartRange(days) {
            sleepChartRange = days;
            // ボタンの見た目更新
            document.querySelectorAll('.chart-range-btn').forEach(btn => {
                if (parseInt(btn.dataset.range) === days) {
                    btn.classList.remove('text-gray-400', 'hover:bg-gray-800');
                    btn.classList.add('bg-gray-700', 'text-white');
                } else {
                    btn.classList.add('text-gray-400', 'hover:bg-gray-800');
                    btn.classList.remove('bg-gray-700', 'text-white');
                }
            });
            renderSleepChart();
        }

        function renderSleepChart() {
            const svg = document.getElementById('sleep-chart-svg');
            if (!svg) return;
            svg.innerHTML = '';

            const today = getToday();
            const days = [];

            // X軸: 日付 (左が過去、右が今日)
            for (let i = sleepChartRange - 1; i >= 0; i--) {
                const d = new Date(today);
                d.setDate(d.getDate() - i);
                days.push(formatDate(d));
            }

            // 描画サイズ定数
            const width = svg.clientWidth || 300;
            const height = svg.clientHeight || 150;
            const padding = { top: 20, right: 10, bottom: 20, left: 30 };
            const chartW = width - padding.left - padding.right;
            const chartH = height - padding.top - padding.bottom;

            // Y軸スケール: 前日18:00 (-360) ～ 当日18:00 (1080)
            // これにより 0:00 が中央やや上に来て、睡眠(夜〜朝)が連続して表示される
            const minMin = -360;
            const maxMin = 1080;
            const rangeMin = 1440;

            // 時刻文字列を分に変換 (0:00基準)
            // isPrevBed: 前日の就寝時間かどうか
            const getMinutes = (timeStr, isPrevBed) => {
                if (!timeStr) return null;
                const [h, m] = timeStr.split(':').map(Number);
                let total = h * 60 + m;

                if (isPrevBed) {
                    // 前日の就寝時間の場合
                    // 12:00以降なら前日の夜とみなしてマイナスオフセット
                    // 00:00〜12:00なら当日の未明とみなしてそのまま（ただし前日データ由来なので当日の早朝寝と同じ扱い）
                    // ※通常「就寝」は夜なので、例えば23:00なら-60、25:00(01:00)なら60となるべきだが
                    // input type=timeは01:00で返ってくる。
                    // 文脈的に「前日のログ」にある「01:00」は「前日の深夜25時」＝「当日の01:00」なのでそのまま。
                    // 「前日のログ」にある「23:00」は「前日の23時」なので「当日の-60分」。
                    if (total > 720) { // 12:00以後は前日扱い
                        total -= 1440;
                    }
                    // 12:00以前(午前中)はそのまま（深夜就寝）
                } else {
                    // 当日の起床時間
                    // そのまま
                }
                return total;
            };

            const getY = (min) => {
                if (min === null) return null;
                if (min < minMin || min > maxMin) return null;
                const percent = (min - minMin) / rangeMin;
                return padding.top + (percent * chartH);
            };

            const getX = (idx) => {
                const colWidth = chartW / days.length;
                return padding.left + (idx * colWidth) + (colWidth / 2);
            };

            // コラム幅
            const colWidth = chartW / days.length;

            // --- 1. 時間ガイドライン (横線) - 3時間ごと ---
            // -360(18), -180(21), 0(0), 180(3), 360(6), 540(9), 720(12), 900(15), 1080(18)
            for (let m = minMin; m <= maxMin; m += 180) {
                const y = getY(m);
                if (y === null) continue;

                // 24時は0時表記、それ以外は時刻
                let labelHour = Math.floor(m / 60);
                if (labelHour < 0) labelHour += 24;
                if (labelHour >= 24) labelHour -= 24;

                const isZero = (m === 0);

                // line
                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                line.setAttribute("x1", padding.left);
                line.setAttribute("y1", y);
                line.setAttribute("x2", width - padding.right);
                line.setAttribute("y2", y);
                line.setAttribute("stroke", isZero ? "#64748b" : "#334155");
                line.setAttribute("stroke-width", "1");
                if (!isZero) line.setAttribute("stroke-dasharray", "2 2");
                svg.appendChild(line);

                // label
                const txt = document.createElementNS("http://www.w3.org/2000/svg", "text");
                txt.setAttribute("x", padding.left - 5);
                txt.setAttribute("y", y + 3);
                txt.setAttribute("text-anchor", "end");
                txt.setAttribute("fill", isZero ? "#cbd5e1" : "#64748b");
                txt.setAttribute("font-size", "8");
                txt.textContent = String(labelHour);
                svg.appendChild(txt);
            }

            // --- 2. 日付グリッド (縦線) & データプロット ---
            const barWidth = Math.max(2, colWidth * 0.7);

            days.forEach((dStr, idx) => {
                const xCenter = getX(idx);
                const xLeft = padding.left + (idx * colWidth);

                // 縦グリッド線
                const vLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
                vLine.setAttribute("x1", xLeft);
                vLine.setAttribute("y1", padding.top);
                vLine.setAttribute("x2", xLeft);
                vLine.setAttribute("y2", height - padding.bottom);
                vLine.setAttribute("stroke", "#1e293b");
                vLine.setAttribute("stroke-width", "1");
                svg.appendChild(vLine);

                // 右端の閉じ線
                if (idx === days.length - 1) {
                    const xRight = padding.left + ((idx + 1) * colWidth);
                    const vLineR = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    vLineR.setAttribute("x1", xRight);
                    vLineR.setAttribute("y1", padding.top);
                    vLineR.setAttribute("x2", xRight);
                    vLineR.setAttribute("y2", height - padding.bottom);
                    vLineR.setAttribute("stroke", "#1e293b");
                    vLineR.setAttribute("stroke-width", "1");
                    svg.appendChild(vLineR);
                }

                // 日付ラベル
                const showLabel = (sleepChartRange <= 14) || (idx % 3 === 0);

                if (showLabel) {
                    const dObj = new Date(dStr);
                    const txt = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    txt.setAttribute("x", xCenter);
                    txt.setAttribute("y", height - 5);
                    txt.setAttribute("text-anchor", "middle");
                    txt.setAttribute("fill", "#94a3b8");
                    txt.setAttribute("font-size", "8");
                    txt.textContent = `${dObj.getMonth() + 1}/${dObj.getDate()}`;
                    svg.appendChild(txt);
                }

                // データプロット
                const logCurr = (appData.sleepLog && appData.sleepLog[dStr]);

                const dObj = new Date(dStr);
                const prevD = new Date(dObj);
                prevD.setDate(prevD.getDate() - 1);
                const prevStr = formatDate(prevD);
                const logPrev = (appData.sleepLog && appData.sleepLog[prevStr]);

                if (logCurr || logPrev) {
                    const minBed = logPrev ? getMinutes(logPrev.bed, true) : null;
                    const minWake = logCurr ? getMinutes(logCurr.wake, false) : null;

                    const yBed = getY(minBed);
                    const yWake = getY(minWake);

                    if (yBed !== null && yWake !== null && yWake > yBed) {
                        const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                        rect.setAttribute("x", xCenter - barWidth / 2);
                        rect.setAttribute("y", yBed);
                        rect.setAttribute("width", barWidth);
                        rect.setAttribute("height", yWake - yBed);
                        rect.setAttribute("rx", "1");
                        rect.setAttribute("fill", "rgba(139, 92, 246, 0.5)");
                        rect.setAttribute("stroke", "none");
                        svg.appendChild(rect);
                    }

                    const drawPoint = (y, color) => {
                        if (y === null) return;
                        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                        circle.setAttribute("cx", xCenter);
                        circle.setAttribute("cy", y);
                        circle.setAttribute("r", "2.5");
                        circle.setAttribute("fill", color);
                        circle.setAttribute("stroke", "#1e293b");
                        circle.setAttribute("stroke-width", "1");
                        svg.appendChild(circle);
                    };

                    drawPoint(yWake, "#facc15"); // 黄色 (起床)
                    drawPoint(yBed, "#c084fc");   // 紫色 (就寝)
                }
            });
        }

        // 初期化時に呼ぶ
        // updateUIの最後に renderSleepChart() を追加する必要がある


        // ナビゲーションのイベント設定
        document.querySelectorAll('.nav-btn').forEach(btn => {
            btn.onclick = () => {
                if (btn.dataset.target) {
                    switchTab(btn.dataset.target);
                }
            };
        });

        document.getElementById('record-prev-day').onclick = () => { currentRecordDate.setDate(currentRecordDate.getDate() - 1); renderRecordLists(); };
        document.getElementById('record-next-day').onclick = () => { currentRecordDate.setDate(currentRecordDate.getDate() + 1); renderRecordLists(); };
        // カレンダーの月移動イベントを再設定
        document.addEventListener('click', (e) => {
            if (e.target.closest('#prev-month')) {
                currentCalendarDate.setMonth(currentCalendarDate.getMonth() - 1);
                renderCalendar();
            }
            if (e.target.closest('#next-month')) {
                currentCalendarDate.setMonth(currentCalendarDate.getMonth() + 1);
                renderCalendar();
            }
        });
        // ★追加：テーマ切り替え機能
        function toggleTheme() {
            const html = document.documentElement;
            const isLight = html.classList.toggle('light-mode');

            updateThemeBtn(isLight);
            updateChartColors();

            // 設定を保存
            localStorage.setItem('app_theme', isLight ? 'light' : 'dark');
        }

        function updateThemeBtn(isLight) {
            const btn = document.getElementById('theme-toggle-btn');
            if (btn) {
                if (isLight) {
                    btn.innerHTML = '<i class="fas fa-sun text-orange-400"></i> <span class="text-gray-600">ライトモード中</span>';
                    btn.classList.replace('bg-gray-700', 'bg-gray-200');
                    btn.classList.replace('text-white', 'text-gray-600');
                } else {
                    btn.innerHTML = '<i class="fas fa-moon text-yellow-300"></i> <span>ダークモード中</span>';
                    btn.classList.replace('bg-gray-200', 'bg-gray-700');
                    btn.classList.replace('text-gray-600', 'text-white');
                }
            }
        }

        // 起動時に保存されたテーマを適用
        (function initTheme() {
            const savedTheme = localStorage.getItem('app_theme');
            if (savedTheme === 'light') {
                document.documentElement.classList.add('light-mode');
            }
            // ボタンの表示はHTML読み込み後に行うため、window.onload等で再度呼ぶか、
            // 設定モーダルを開いた時に更新するようにします
        })();
        window.onload = () => {
            // ログイン状態の監視を少し丁寧に
            firebase.auth().onAuthStateChanged((user) => {
                const modal = document.getElementById('login-modal');
                if (user) {
                    currentUserDocId = user.uid;
                    modal.classList.add('hidden');
                    // ログインが確定してから1秒後に通信を開始する
                    setTimeout(() => {
                        startListening();
                        //syncFromGoogleTasks(); // ★自動同期したい場合はこの行が必要です！
                    }, 1000);
                } else {
                    currentUserDocId = null;
                    modal.classList.remove('hidden');
                    document.body.style.opacity = 1;
                }
            });
            updateChartColors();
            updateChartColors();
            initStudyTimeSelects(); // ★追加: セレクトボックス初期化
            // アコーディオンの初期状態を設定（直近で開いていたものを記憶しても良いが、一旦デフォルトは閉じておくか、最初だけ開く）
            // タブの初期表示
            switchHabitTab('tab-habit-check');
        };

        // --- Global Data Migration ---
        function getBlankData() {
            return {
                subjects: JSON.parse(JSON.stringify(defaultSubjects)),
                schedules: {},
                currentSubjectId: 'chemistry', // 初期選択は化学
                sleepLog: {},
                studyLog: {}, // ★追加
                ticker: JSON.parse(JSON.stringify(defaultTicker))
            };
        }

        // --- Tab Logic ---
        function switchHabitTab(tabId) {
            // すべてのタブコンテンツを非表示
            ['tab-habit-check', 'tab-study-time', 'tab-life-rhythm'].forEach(id => {
                document.getElementById(id).classList.add('hidden');
            });
            // すべてのタブボタンのスタイルを非アクティブ（グレー）に
            ['btn-tab-habit-check', 'btn-tab-study-time', 'btn-tab-life-rhythm'].forEach(id => {
                const btn = document.getElementById(id);
                btn.classList.remove('bg-gray-700', 'text-white', 'shadow');
                btn.classList.add('text-gray-400');
            });

            // 選択されたタブを表示
            document.getElementById(tabId).classList.remove('hidden');

            // 選択されたボタンをアクティブ（背景色・白文字）に
            const activeBtn = document.getElementById('btn-' + tabId);
            activeBtn.classList.remove('text-gray-400');
            activeBtn.classList.add('bg-gray-700', 'text-white', 'shadow');

            // グラフ描画などが必要な場合
            if (tabId === 'tab-study-time') {
                renderStudyChart();
            } else if (tabId === 'tab-life-rhythm') {
                renderSleepChart();
            }
        }

        // --- Study Time Logic ---
        let studyChartRange = 7;
        let studyTimeChart = null;

        function initStudyTimeSelects() {
            // Main Tab Picker
            initSinglePicker('study-log-hours-main', 'study-log-minutes-scroll-main', 'study-log-minutes-main');

            // Modal Picker (using the IDs currently in the modal)
            // Note: The modal HTML (from previous steps) has IDs: study-log-hours, study-log-minutes-scroll, study-log-minutes
            // I should probably rename them to be consistent, but for now let's target them as is.
            initSinglePicker('study-log-hours', 'study-log-minutes-scroll', 'study-log-minutes');

            loadStudyLogDate();
        }

        function initSinglePicker(hourId, scrollId, inputId) {
            const hourSelect = document.getElementById(hourId);
            const minuteScroll = document.getElementById(scrollId);
            const minuteInput = document.getElementById(inputId);

            if (!hourSelect || !minuteScroll || !minuteInput) return;

            hourSelect.innerHTML = '';
            minuteScroll.innerHTML = '';

            // Hours
            for (let i = 0; i <= 24; i++) {
                const opt = document.createElement('option');
                opt.value = i;
                opt.textContent = i;
                hourSelect.appendChild(opt);
            }

            // Minutes (Infinite Scroll)
            const createItem = (val) => {
                const div = document.createElement('div');
                div.className = "h-[46px] flex items-center justify-center text-xl font-mono text-white snap-center shrink-0 w-full";
                div.textContent = String(val).padStart(2, '0');
                div.dataset.value = val;
                return div;
            };

            for (let set = 0; set < 3; set++) {
                for (let i = 0; i < 60; i++) {
                    minuteScroll.appendChild(createItem(i));
                }
            }

            const itemHeight = 46;
            const singleSetHeight = itemHeight * 60;
            minuteScroll.scrollTop = singleSetHeight; // Center set

            let isScrolling = false;
            minuteScroll.addEventListener('scroll', () => {
                if (isScrolling) return;
                const currentScroll = minuteScroll.scrollTop;
                if (currentScroll < itemHeight * 10) {
                    minuteScroll.scrollTop = currentScroll + singleSetHeight;
                } else if (currentScroll > singleSetHeight * 2 - itemHeight * 10) {
                    minuteScroll.scrollTop = currentScroll - singleSetHeight;
                }
                const centerIndex = Math.round(minuteScroll.scrollTop / itemHeight);
                const val = centerIndex % 60;
                if (minuteInput.value != val) {
                    minuteInput.value = val;
                }
            });
        }

        function loadStudyLogDate() {
            const dateInput = document.getElementById('study-log-date');
            if (!dateInput.value) dateInput.value = getTodayStr();
            const dateStr = dateInput.value;

            // ラベル更新
            const label = document.getElementById('study-time-label');
            if (dateStr === getTodayStr()) {
                label.textContent = "今日の勉強時間";
            } else {
                const d = new Date(dateStr);
                label.textContent = `${d.getMonth() + 1}/${d.getDate()}の勉強時間`;
            }

            const log = (appData.studyLog && appData.studyLog[dateStr]) || { time: 0 };
            const hours = Math.floor(log.time / 60);
            const minutes = log.time % 60;

            // Sync Main Picker
            syncPickerValues('study-log-hours-main', 'study-log-minutes-scroll-main', 'study-log-minutes-main', hours, minutes);

            // Sync Modal Picker (if it exists)
            syncPickerValues('study-log-hours', 'study-log-minutes-scroll', 'study-log-minutes', hours, minutes);
        }

        function syncPickerValues(hourId, scrollId, inputId, hours, minutes) {
            const hourSelect = document.getElementById(hourId);
            const minuteScroll = document.getElementById(scrollId);
            const minuteInput = document.getElementById(inputId);

            if (hourSelect) hourSelect.value = hours;
            if (minuteInput) minuteInput.value = minutes;
            if (minuteScroll) {
                const itemHeight = 46;
                const singleSetHeight = itemHeight * 60;
                const targetScroll = singleSetHeight + (minutes * itemHeight);
                minuteScroll.scrollTop = targetScroll;
            }
        }

        function shiftStudyLogDate(diff) {
            const dateInput = document.getElementById('study-log-date');
            if (!dateInput.value) dateInput.value = getTodayStr();

            const current = new Date(dateInput.value);
            current.setDate(current.getDate() + diff);
            dateInput.value = formatDate(current);
            loadStudyLogDate();
        }

        function saveStudyLog() {
            const dateStr = document.getElementById('study-log-date').value;
            if (!dateStr) return;

            const h = parseInt(document.getElementById('study-log-hours').value) || 0;
            const m = parseInt(document.getElementById('study-log-minutes').value) || 0;
            const totalMinutes = h * 60 + m;

            if (!appData.studyLog) appData.studyLog = {};
            appData.studyLog[dateStr] = { time: totalMinutes };

            // 自動チェック判定
            checkStudyTimeAutoChallenge(dateStr, totalMinutes);

            saveData();
            renderStudyChart();
            showToast("勉強時間を記録しました");
        }

        function changeStudyChartRange(days) {
            studyChartRange = days;
            document.querySelectorAll('.study-chart-range-btn').forEach(btn => {
                if (parseInt(btn.dataset.range) === days) {
                    btn.classList.remove('text-gray-400', 'hover:bg-gray-800');
                    btn.classList.add('bg-gray-700', 'text-white');
                } else {
                    btn.classList.add('text-gray-400', 'hover:bg-gray-800');
                    btn.classList.remove('bg-gray-700', 'text-white');
                }
            });
            renderStudyChart();
        }

        function renderStudyChart() {
            const canvas = document.getElementById('studyTimeChart');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const today = getToday();
            const labels = [];
            const data = [];
            let totalTime = 0;

            // X軸: 日付 (左が過去、右が今日)
            for (let i = studyChartRange - 1; i >= 0; i--) {
                const d = new Date(today);
                d.setDate(d.getDate() - i);
                const dStr = formatDate(d);
                labels.push(`${d.getMonth() + 1}/${d.getDate()}`);

                const log = (appData.studyLog && appData.studyLog[dStr]);
                const minutes = log ? log.time : 0;
                data.push(minutes / 60); // 時間単位で表示
                totalTime += minutes;
            }

            // 合計時間の表示更新
            const th = Math.floor(totalTime / 60);
            const tm = totalTime % 60;
            document.getElementById('study-total-display').textContent = `${th}h ${tm}m`;

            const isLight = document.documentElement.classList.contains('light-mode');
            const barColor = isLight ? '#3b82f6' : '#60a5fa';
            const gridColor = isLight ? '#cbd5e1' : '#334155';
            const textColor = isLight ? '#64748b' : '#94a3b8';

            if (studyTimeChart) {
                studyTimeChart.destroy();
            }

            studyTimeChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: '勉強時間 (時間)',
                        data: data,
                        backgroundColor: barColor,
                        borderRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            grid: { display: false, color: gridColor },
                            ticks: { color: textColor, font: { size: 10 } }
                        },
                        y: {
                            beginAtZero: true,
                            grid: { color: gridColor, borderDash: [2, 2] },
                            ticks: { color: textColor, font: { size: 10 } }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const val = context.raw;
                                    const h = Math.floor(val);
                                    const m = Math.round((val - h) * 60);
                                    return `${h}時間 ${m}分`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function checkStudyTimeAutoChallenge(dateStr, minutes) {
            const challenges = getActiveChallenges();
            let updated = false;

            challenges.forEach(c => {
                if (c.autoCheckType === 'study_time' && c.autoCheckTime) {
                    const target = parseInt(c.autoCheckTime);
                    if (minutes >= target) {
                        if (!c.challengeHistory) c.challengeHistory = {};
                        if (!c.challengeHistory[dateStr]) {
                            c.challengeHistory[dateStr] = true;
                            updated = true;
                        }
                    }
                }
            });

            if (updated) {
                renderChallengeScreen();
                showToast("目標達成！チャレンジを更新しました");
            }
        }    </script>
</body>

</html>